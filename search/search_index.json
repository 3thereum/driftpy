{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Drift-v2 Python SDK","text":"<p>DriftPy is the Python SDK for Drift-v2 on Solana.  It allows you to trade and fetch data from Drift using Python.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install driftpy\n</code></pre> <p>Note: requires Python &gt;= 3.10.</p>"},{"location":"#key-components","title":"Key Components","text":"<ul> <li><code>ClearingHouse</code> / <code>clearing_house.py</code>: Used to interact with the protocol (deposit, withdraw, trade, lp, etc.)</li> <li><code>ClearingHouseUser</code> / <code>clearing_house_user.py</code>: Used to fetch data from the protocol and view user metrics (leverage, free collateral, etc.)</li> <li><code>accounts.py</code>: Used to retrieve specific on-chain accounts (State, PerpMarket, SpotMarket, etc.)</li> <li><code>addresses.py</code>: Used to derive on-chain addresses of the accounts (publickey of the sol-market)</li> </ul>"},{"location":"#example","title":"Example","text":"<pre><code>from solana.keypair import Keypair\nfrom driftpy.clearing_house import ClearingHouse \nfrom driftpy.clearing_house_user import ClearingHouseUser\nfrom driftpy.constants.numeric_constants import BASE_PRECISION, AMM_RESERVE_PRECISION \n\nfrom anchorpy import Provider, Wallet\nfrom solana.rpc.async_api import AsyncClient\n\n# load keypair from file \nKEYPATH = '../your-keypair-secret.json'\nwith open(KEYPATH, 'r') as f: \n    secret = json.load(f) \nkp = Keypair.from_secret_key(bytes(secret))\n\n# create clearing house for mainnet \nENV = 'mainnet' \nconfig = configs[ENV]\nwallet = Wallet(kp)\nconnection = AsyncClient(config.default_http)\nprovider = Provider(connection, wallet)\n\nclearing_house = ClearingHouse.from_config(config, provider)\nclearing_house_user = ClearingHouseUser(clearing_house)\n\n# open a 10 SOL long position\nsig = await clearing_house.open_position(\n    PositionDirection.LONG(), # long\n    int(10 * BASE_PRECISION), # 10 in base precision\n    0, # sol market index\n) \n\n# mint 100 LP shares on the SOL market\nawait clearing_house.add_liquidity(\n    int(100 * AMM_RESERVE_PRECISION), \n    0, \n)\n\n# inspect user's leverage \nleverage = await clearing_house_user.get_leverage()\nprint('current leverage:', leverage / 10_000)\n\n# you can also inspect other accounts information using the (authority=) flag\nbigz_chu = ClearingHouseUser(clearing_house, authority=PublicKey('bigZ'))\nleverage = await bigz_chu.get_leverage()\nprint('bigZs leverage:', leverage / 10_000)\n\n# clearing house user calls can be expensive on the rpc so we can cache them \nclearing_house_user = ClearingHouseUser(clearing_house, use_cache=True)\nawait clearing_house_user.set_cache()\n\n# works without any rpc calls (uses the cached data)\nupnl = await chu.get_unrealized_pnl(with_funding=True)\nprint('upnl:', upnl)\n</code></pre>"},{"location":"accounts/","title":"Accounts","text":"<p>These functions are used to retrieve specific on-chain accounts (State, PerpMarket, SpotMarket, etc.)</p>"},{"location":"accounts/#example","title":"Example","text":"<pre><code>clearing_house = ClearingHouse.from_config(config, provider)\n\n# get sol market info \nsol_market_index = 0\nsol_market = await get_perp_market_account(clearing_house.program, sol_market_index)\nprint(\n    sol_market.amm.sqrt_k, \n    sol_market.amm.base_asset_amount_long, \n    sol_market.amm.base_asset_amount_short, \n)\n\n# get usdc spot market info\nusdc_spot_market_index = 0\nusdc_market = await get_spot_market_account(clearing_house.program, usdc_spot_market_index)\nprint(\n    usdc.market_index, \n    usdc.deposit_balance, \n    usdc.borrow_balance, \n)\n</code></pre>"},{"location":"accounts/#driftpy.accounts","title":"<code>accounts</code>","text":""},{"location":"accounts/#driftpy.accounts.get_all_perp_market_accounts","title":"<code>get_all_perp_market_accounts(program)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/accounts.py</code> <pre><code>async def get_all_perp_market_accounts(program: Program) -&gt; list[ProgramAccount]:\n    return await program.account[\"PerpMarket\"].all()\n</code></pre>"},{"location":"accounts/#driftpy.accounts.get_all_spot_market_accounts","title":"<code>get_all_spot_market_accounts(program)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/accounts.py</code> <pre><code>async def get_all_spot_market_accounts(program: Program) -&gt; list[ProgramAccount]:\n    return await program.account[\"SpotMarket\"].all()\n</code></pre>"},{"location":"accounts/#driftpy.accounts.get_if_stake_account","title":"<code>get_if_stake_account(program, authority, spot_market_index)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/accounts.py</code> <pre><code>async def get_if_stake_account(\n    program: Program, authority: PublicKey, spot_market_index: int\n) -&gt; InsuranceFundStake:\n    if_stake_pk = get_insurance_fund_stake_public_key(\n        program.program_id, authority, spot_market_index\n    )\n    response = await program.account[\"InsuranceFundStake\"].fetch(if_stake_pk)\n    return cast(InsuranceFundStake, response)\n</code></pre>"},{"location":"accounts/#driftpy.accounts.get_perp_market_account","title":"<code>get_perp_market_account(program, market_index)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/accounts.py</code> <pre><code>async def get_perp_market_account(program: Program, market_index: int) -&gt; PerpMarket:\n    market_public_key = get_perp_market_public_key(program.program_id, market_index)\n    response = await program.account[\"PerpMarket\"].fetch(market_public_key)\n    return cast(PerpMarket, response)\n</code></pre>"},{"location":"accounts/#driftpy.accounts.get_spot_market_account","title":"<code>get_spot_market_account(program, spot_market_index)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/accounts.py</code> <pre><code>async def get_spot_market_account(\n    program: Program, spot_market_index: int\n) -&gt; SpotMarket:\n    spot_market_public_key = get_spot_market_public_key(\n        program.program_id, spot_market_index\n    )\n    response = await program.account[\"SpotMarket\"].fetch(spot_market_public_key)\n    return cast(SpotMarket, response)\n</code></pre>"},{"location":"accounts/#driftpy.accounts.get_state_account","title":"<code>get_state_account(program)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/accounts.py</code> <pre><code>async def get_state_account(program: Program) -&gt; State:\n    state_public_key = get_state_public_key(program.program_id)\n    response = await program.account[\"State\"].fetch(state_public_key)\n    return cast(State, response)\n</code></pre>"},{"location":"accounts/#driftpy.accounts.get_user_account","title":"<code>get_user_account(program, authority, subaccount_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/accounts.py</code> <pre><code>async def get_user_account(\n    program: Program,\n    authority: PublicKey,\n    subaccount_id: int = 0,\n) -&gt; User:\n    user_public_key = get_user_account_public_key(\n        program.program_id, authority, subaccount_id\n    )\n    response = await program.account[\"User\"].fetch(user_public_key)\n    return cast(User, response)\n</code></pre>"},{"location":"accounts/#driftpy.accounts.get_user_stats_account","title":"<code>get_user_stats_account(program, authority)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/accounts.py</code> <pre><code>async def get_user_stats_account(\n    program: Program,\n    authority: PublicKey,\n) -&gt; UserStats:\n    user_stats_public_key = get_user_stats_account_public_key(\n        program.program_id,\n        authority,\n    )\n    response = await program.account[\"UserStats\"].fetch(user_stats_public_key)\n    return cast(UserStats, response)\n</code></pre>"},{"location":"addresses/","title":"Addresses","text":"<p>These functions are used to derive on-chain addresses of the accounts (publickey of the sol-market)</p>"},{"location":"addresses/#driftpy.addresses","title":"<code>addresses</code>","text":""},{"location":"addresses/#driftpy.addresses.get_clearing_house_signer_public_key","title":"<code>get_clearing_house_signer_public_key(program_id)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/addresses.py</code> <pre><code>def get_clearing_house_signer_public_key(\n    program_id: PublicKey,\n) -&gt; PublicKey:\n    return PublicKey.find_program_address([b\"drift_signer\"], program_id)[0]\n</code></pre>"},{"location":"addresses/#driftpy.addresses.get_insurance_fund_stake_public_key","title":"<code>get_insurance_fund_stake_public_key(program_id, authority, spot_market_index)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/addresses.py</code> <pre><code>def get_insurance_fund_stake_public_key(\n    program_id: PublicKey,\n    authority: PublicKey,\n    spot_market_index: int,\n) -&gt; PublicKey:\n    return PublicKey.find_program_address(\n        [b\"insurance_fund_stake\", bytes(authority), int_to_le_bytes(spot_market_index)],\n        program_id,\n    )[0]\n</code></pre>"},{"location":"addresses/#driftpy.addresses.get_insurance_fund_vault_public_key","title":"<code>get_insurance_fund_vault_public_key(program_id, spot_market_index)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/addresses.py</code> <pre><code>def get_insurance_fund_vault_public_key(\n    program_id: PublicKey,\n    spot_market_index: int,\n) -&gt; PublicKey:\n    return PublicKey.find_program_address(\n        [b\"insurance_fund_vault\", int_to_le_bytes(spot_market_index)], program_id\n    )[0]\n</code></pre>"},{"location":"addresses/#driftpy.addresses.get_perp_market_public_key","title":"<code>get_perp_market_public_key(program_id, market_index)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/addresses.py</code> <pre><code>def get_perp_market_public_key(\n    program_id: PublicKey,\n    market_index: int,\n) -&gt; PublicKey:\n    return PublicKey.find_program_address(\n        [b\"perp_market\", int_to_le_bytes(market_index)], program_id\n    )[0]\n</code></pre>"},{"location":"addresses/#driftpy.addresses.get_spot_market_public_key","title":"<code>get_spot_market_public_key(program_id, spot_market_index)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/addresses.py</code> <pre><code>def get_spot_market_public_key(\n    program_id: PublicKey,\n    spot_market_index: int,\n) -&gt; PublicKey:\n    return PublicKey.find_program_address(\n        [b\"spot_market\", int_to_le_bytes(spot_market_index)], program_id\n    )[0]\n</code></pre>"},{"location":"addresses/#driftpy.addresses.get_spot_market_vault_authority_public_key","title":"<code>get_spot_market_vault_authority_public_key(program_id, spot_market_index)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/addresses.py</code> <pre><code>def get_spot_market_vault_authority_public_key(\n    program_id: PublicKey,\n    spot_market_index: int,\n) -&gt; PublicKey:\n    return PublicKey.find_program_address(\n        [b\"spot_market_vault_authority\", int_to_le_bytes(spot_market_index)], program_id\n    )[0]\n</code></pre>"},{"location":"addresses/#driftpy.addresses.get_spot_market_vault_public_key","title":"<code>get_spot_market_vault_public_key(program_id, spot_market_index)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/addresses.py</code> <pre><code>def get_spot_market_vault_public_key(\n    program_id: PublicKey,\n    spot_market_index: int,\n) -&gt; PublicKey:\n    return PublicKey.find_program_address(\n        [b\"spot_market_vault\", int_to_le_bytes(spot_market_index)], program_id\n    )[0]\n</code></pre>"},{"location":"addresses/#driftpy.addresses.get_state_public_key","title":"<code>get_state_public_key(program_id)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/addresses.py</code> <pre><code>def get_state_public_key(\n    program_id: PublicKey,\n) -&gt; PublicKey:\n    return PublicKey.find_program_address([b\"drift_state\"], program_id)[0]\n</code></pre>"},{"location":"addresses/#driftpy.addresses.get_user_account_public_key","title":"<code>get_user_account_public_key(program_id, authority, user_id=0)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/addresses.py</code> <pre><code>def get_user_account_public_key(\n    program_id: PublicKey,\n    authority: PublicKey,\n    user_id=0,\n) -&gt; PublicKey:\n    return PublicKey.find_program_address(\n        [b\"user\", bytes(authority), int_to_le_bytes(user_id)], program_id\n    )[0]\n</code></pre>"},{"location":"addresses/#driftpy.addresses.get_user_stats_account_public_key","title":"<code>get_user_stats_account_public_key(program_id, authority)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/addresses.py</code> <pre><code>def get_user_stats_account_public_key(\n    program_id: PublicKey,\n    authority: PublicKey,\n) -&gt; PublicKey:\n    return PublicKey.find_program_address(\n        [b\"user_stats\", bytes(authority)], program_id\n    )[0]\n</code></pre>"},{"location":"addresses/#driftpy.addresses.int_to_le_bytes","title":"<code>int_to_le_bytes(a)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/addresses.py</code> <pre><code>def int_to_le_bytes(a: int):\n    return a.to_bytes(2, \"little\")\n</code></pre>"},{"location":"clearing_house/","title":"Clearing House","text":"<p>This object is used to interact with the protocol (deposit, withdraw, trade, lp, etc.)</p>"},{"location":"clearing_house/#example","title":"Example","text":"<pre><code>clearing_house = ClearingHouse.from_config(config, provider)\n\n# open a 10 SOL long position\nsig = await clearing_house.open_position(\n    PositionDirection.LONG(), # long\n    int(10 * BASE_PRECISION), # 10 in base precision\n    0, # sol market index\n) \n\n# mint 100 LP shares on the SOL market\nawait clearing_house.add_liquidity(\n    int(100 * AMM_RESERVE_PRECISION), \n    0, \n)\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house","title":"<code>clearing_house</code>","text":""},{"location":"clearing_house/#driftpy.clearing_house.DEFAULT_USER_NAME","title":"<code>DEFAULT_USER_NAME = 'Main Account'</code>  <code>module-attribute</code>","text":""},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse","title":"<code>ClearingHouse</code>","text":"<p>This class is the main way to interact with Drift Protocol including depositing, opening new positions, closing positions, placing orders, etc.</p> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>class ClearingHouse:\n\"\"\"This class is the main way to interact with Drift Protocol including\n    depositing, opening new positions, closing positions, placing orders, etc.\n    \"\"\"\n\n    def __init__(self, program: Program, signer: Keypair = None, authority: PublicKey = None):\n\"\"\"Initializes the clearing house object -- likely want to use the .from_config method instead of this one\n\n        Args:\n            program (Program): Drift anchor program (see from_config on how to initialize it)\n            authority (Keypair, optional): Authority of all txs - if None will default to the Anchor Provider.Wallet Keypair.\n        \"\"\"\n        self.program = program\n        self.program_id = program.program_id\n        self.user_index = None\n\n        if signer is None:\n            signer = program.provider.wallet.payer\n\n        self.signer = signer\n        self.authority = authority\n        self.signers = [self.signer]\n        self.usdc_ata = None\n        self.spot_market_atas = {}\n        self.subaccounts = [0]\n\n    @staticmethod\n    def from_config(config: Config, provider: Provider, authority: Keypair = None):\n\"\"\"Initializes the clearing house object from a Config\n\n        Args:\n            config (Config): the config to initialize form\n            provider (Provider): anchor provider\n            authority (Keypair, optional):  _description_. Defaults to None.\n\n        Returns:\n            ClearingHouse: the clearing house object\n        \"\"\"\n        # read the idl\n        file = Path(str(driftpy.__path__[0]) + \"/idl/drift.json\")\n        print(file)\n        with file.open() as f:\n            idl_dict = json.load(f)\n        idl = Idl.from_json(idl_dict)\n\n        # create the program\n        program = Program(\n            idl,\n            config.clearing_house_program_id,\n            provider,\n        )\n\n        clearing_house = ClearingHouse(program, authority)\n        clearing_house.config = config\n        clearing_house.idl = idl\n\n        return clearing_house\n\n    def get_user_account_public_key(self, user_id=0) -&gt; PublicKey:\n        return get_user_account_public_key(self.program_id, self.authority, user_id)\n\n    async def get_user(self, user_id=0) -&gt; User:\n        return await get_user_account(self.program, self.authority, user_id)\n\n    def get_state_public_key(self):\n        return get_state_public_key(self.program_id)\n\n    def get_user_stats_public_key(self):\n        return get_user_stats_account_public_key(self.program_id, self.authority)\n\n    async def send_ixs(\n        self,\n        ixs: Union[TransactionInstruction, list[TransactionInstruction]],\n        signers=None,\n    ):\n        if isinstance(ixs, TransactionInstruction):\n            ixs = [ixs]\n\n        tx = Transaction()\n        for ix in ixs:\n            tx.add(ix)\n\n        if signers is None:\n            signers = self.signers\n\n        return await self.program.provider.send(tx, signers=signers)\n\n    async def intialize_user(self, user_id: int = 0):\n\"\"\"intializes a drift user\n\n        Args:\n            user_id (int, optional): subaccount id to initialize. Defaults to 0.\n\n        Returns:\n            str: tx signature\n        \"\"\"\n        ixs = []\n        if user_id == 0:\n            ixs.append(self.get_initialize_user_stats())\n        ix = self.get_initialize_user_instructions(user_id)\n        ixs.append(ix)\n        return await self.send_ixs(ixs)\n\n    def get_initialize_user_stats(\n        self,\n    ):\n        state_public_key = self.get_state_public_key()\n        user_stats_public_key = self.get_user_stats_public_key()\n\n        return self.program.instruction[\"initialize_user_stats\"](\n            ctx=Context(\n                accounts={\n                    \"user_stats\": user_stats_public_key,\n                    \"state\": state_public_key,\n                    \"authority\": self.authority,\n                    \"payer\": self.authority,\n                    \"rent\": SYSVAR_RENT_PUBKEY,\n                    \"system_program\": SYS_PROGRAM_ID,\n                },\n            ),\n        )\n\n    def get_initialize_user_instructions(\n        self, user_id: int = 0, name: str = DEFAULT_USER_NAME\n    ) -&gt; TransactionInstruction:\n        user_public_key = self.get_user_account_public_key(user_id)\n        state_public_key = self.get_state_public_key()\n        user_stats_public_key = self.get_user_stats_public_key()\n\n        if len(name) &gt; 32:\n            raise Exception(\"name too long\")\n\n        name_bytes = bytearray(32)\n        pack_into(f\"{len(name)}s\", name_bytes, 0, name.encode(\"utf-8\"))\n        offset = len(name)\n        for _ in range(32 - len(name)):\n            pack_into(\"1s\", name_bytes, offset, \" \".encode(\"utf-8\"))\n            offset += 1\n\n        str_name_bytes = name_bytes.hex()\n        name_byte_array = []\n        for i in range(0, len(str_name_bytes), 2):\n            name_byte_array.append(int(str_name_bytes[i : i + 2], 16))\n\n        initialize_user_account_ix = self.program.instruction[\"initialize_user\"](\n            user_id,\n            name_byte_array,\n            ctx=Context(\n                accounts={\n                    \"user\": user_public_key,\n                    \"user_stats\": user_stats_public_key,\n                    \"state\": state_public_key,\n                    \"authority\": self.authority,\n                    \"payer\": self.authority,\n                    \"rent\": SYSVAR_RENT_PUBKEY,\n                    \"system_program\": SYS_PROGRAM_ID,\n                },\n            ),\n        )\n        return initialize_user_account_ix\n\n    async def get_remaining_accounts(\n        self,\n        writable_market_index: int = None,\n        writable_spot_market_index: int = None,\n        readable_spot_market_index: int = None,\n        user_id=[0],\n        include_oracles: bool = True,\n        include_spot_markets: bool = True,\n        authority: Optional[Union[PublicKey, Sequence[PublicKey]]] = None,\n    ):\n        if authority is None:\n            authority = [self.authority]\n        elif isinstance(authority, PublicKey):\n            authority = [authority]\n\n        if isinstance(user_id, int):\n            user_id = [user_id]\n        assert len(user_id) == len(authority) or len(user_id) == 0\n\n        accounts = []\n        for pk, id in zip(authority, user_id):\n            user_account = await get_user_account(self.program, pk, id)\n            accounts.append(user_account)\n\n        oracle_map = {}\n        spot_market_map = {}\n        market_map = {}\n\n        async def track_market(market_index, is_writable):\n            perp_market = await get_perp_market_account(self.program, market_index)\n            market_map[market_index] = AccountMeta(\n                pubkey=perp_market.pubkey,\n                is_signer=False,\n                is_writable=is_writable,\n            )\n\n            if include_oracles:\n                spot_market = await get_spot_market_account(\n                    self.program, perp_market.quote_spot_market_index\n                )\n                if spot_market.oracle is not None:\n                    oracle_map[str(spot_market.oracle)] = AccountMeta(\n                        pubkey=spot_market.oracle, is_signer=False, is_writable=False\n                    )\n                oracle_map[str(perp_market.pubkey)] = AccountMeta(\n                    pubkey=perp_market.amm.oracle, is_signer=False, is_writable=False\n                )\n\n        async def track_spot_market(spot_market_index, is_writable):\n            spot_market = await get_spot_market_account(self.program, spot_market_index)\n            spot_market_map[spot_market_index] = AccountMeta(\n                pubkey=spot_market.pubkey,\n                is_signer=False,\n                is_writable=is_writable,\n            )\n\n            if include_oracles:\n                oracle_map[str(spot_market.pubkey)] = AccountMeta(\n                    pubkey=spot_market.oracle, is_signer=False, is_writable=False\n                )\n\n        for user_account in accounts:\n            for position in user_account.perp_positions:\n                if not is_available(position):\n                    market_index = position.market_index\n                    await track_market(market_index, is_writable=True)\n\n            if include_spot_markets:\n                for spot_market_balance in user_account.spot_positions:\n                    if not is_spot_position_available(spot_market_balance):\n                        await track_spot_market(\n                            spot_market_balance.market_index, is_writable=False\n                        )\n\n                if readable_spot_market_index is not None:\n                    if isinstance(readable_spot_market_index, int):\n                        readable_spot_market_index = [readable_spot_market_index]\n\n                    for i in readable_spot_market_index:\n                        await track_spot_market(i, is_writable=False)\n\n        if writable_market_index is not None:\n            if isinstance(writable_market_index, int):\n                writable_market_index = [writable_market_index]\n\n            for i in writable_market_index:\n                await track_market(i, is_writable=True)\n\n        if writable_spot_market_index is not None and include_spot_markets:\n            if isinstance(writable_spot_market_index, int):\n                writable_spot_market_index = [writable_spot_market_index]\n\n            for i in writable_spot_market_index:\n                await track_spot_market(i, is_writable=True)\n\n        remaining_accounts = [\n            *oracle_map.values(),\n            *spot_market_map.values(),\n            *market_map.values(),\n        ]\n\n        return remaining_accounts\n\n    async def withdraw(\n        self,\n        amount: int,\n        spot_market_index: int,\n        user_token_account: PublicKey,\n        reduce_only: bool = False,\n        user_id: int = 0,\n    ):\n\"\"\"withdraws from drift protocol (can also allow borrowing)\n\n        Args:\n            amount (int): amount to withdraw\n            spot_market_index (int):\n            user_token_account (PublicKey): ata of the account to withdraw to\n            reduce_only (bool, optional): if True will only withdraw existing funds else if False will allow taking out borrows. Defaults to False.\n            user_id (int, optional): subaccount. Defaults to 0.\n\n        Returns:\n            str: tx sig\n        \"\"\"\n        return await self.send_ixs(\n            [\n                await self.get_withdraw_collateral_ix(\n                    amount, spot_market_index, user_token_account, reduce_only, user_id\n                )\n            ]\n        )\n\n    async def get_withdraw_collateral_ix(\n        self,\n        amount: int,\n        spot_market_index: int,\n        user_token_account: PublicKey,\n        reduce_only: bool = False,\n        user_id: int = 0,\n    ):\n        spot_market = await get_spot_market_account(self.program, spot_market_index)\n        remaining_accounts = await self.get_remaining_accounts(\n            writable_spot_market_index=spot_market_index,\n            readable_spot_market_index=QUOTE_ASSET_BANK_INDEX,\n            user_id=user_id,\n        )\n        ch_signer = get_clearing_house_signer_public_key(self.program_id)\n\n        return self.program.instruction[\"withdraw\"](\n            spot_market_index,\n            amount,\n            reduce_only,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"spot_market\": spot_market.pubkey,\n                    \"spot_market_vault\": spot_market.vault,\n                    \"drift_signer\": ch_signer,\n                    \"user\": self.get_user_account_public_key(user_id),\n                    \"user_stats\": self.get_user_stats_public_key(),\n                    \"user_token_account\": user_token_account,\n                    \"authority\": self.authority,\n                    \"token_program\": TOKEN_PROGRAM_ID,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def deposit(\n        self,\n        amount: int,\n        spot_market_index: int,\n        user_token_account: PublicKey,\n        user_id: int = 0,\n        reduce_only=False,\n        user_initialized=True,\n    ):\n\"\"\"deposits collateral into protocol\n\n        Args:\n            amount (int): amount to deposit\n            spot_market_index (int):\n            user_token_account (PublicKey):\n            user_id (int, optional): subaccount to deposit into. Defaults to 0.\n            reduce_only (bool, optional): paying back borrow vs depositing new assets. Defaults to False.\n            user_initialized (bool, optional): if need to initialize user account too set this to False. Defaults to True.\n\n        Returns:\n            str: sig\n        \"\"\"\n        return await self.send_ixs(\n            [\n                await self.get_deposit_collateral_ix(\n                    amount,\n                    spot_market_index,\n                    user_token_account,\n                    user_id,\n                    reduce_only,\n                    user_initialized,\n                )\n            ]\n        )\n\n    async def get_deposit_collateral_ix(\n        self,\n        amount: int,\n        spot_market_index: int,\n        user_token_account: PublicKey,\n        user_id: int = 0,\n        reduce_only=False,\n        user_initialized=True,\n    ) -&gt; TransactionInstruction:\n        if user_initialized:\n            remaining_accounts = await self.get_remaining_accounts(\n                writable_spot_market_index=spot_market_index, user_id=user_id\n            )\n        else:\n            raise Exception(\"not implemented...\")\n\n        spot_market_pk = get_spot_market_public_key(self.program_id, spot_market_index)\n        spot_vault_public_key = get_spot_market_vault_public_key(\n            self.program_id, spot_market_index\n        )\n        user_account_public_key = get_user_account_public_key(\n            self.program_id, self.authority, user_id\n        )\n        return self.program.instruction[\"deposit\"](\n            spot_market_index,\n            amount,\n            reduce_only,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"spot_market\": spot_market_pk,\n                    \"spot_market_vault\": spot_vault_public_key,\n                    \"user\": user_account_public_key,\n                    \"user_stats\": self.get_user_stats_public_key(),\n                    \"user_token_account\": user_token_account,\n                    \"authority\": self.authority,\n                    \"token_program\": TOKEN_PROGRAM_ID,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def add_liquidity(self, amount: int, market_index: int, user_id: int = 0):\n\"\"\"mint LP tokens and add liquidity to the DAMM\n\n        Args:\n            amount (int): amount of lp tokens to mint\n            market_index (int): market you want to lp in\n            user_id (int, optional): subaccount id. Defaults to 0.\n\n        Returns:\n            str: tx sig\n        \"\"\"\n        return await self.send_ixs(\n            [await self.get_add_liquidity_ix(amount, market_index, user_id)]\n        )\n\n    async def get_add_liquidity_ix(\n        self, amount: int, market_index: int, user_id: int = 0\n    ):\n        remaining_accounts = await self.get_remaining_accounts(\n            writable_market_index=market_index, user_id=user_id\n        )\n        user_account_public_key = get_user_account_public_key(\n            self.program_id, self.authority, user_id\n        )\n\n        return self.program.instruction[\"add_perp_lp_shares\"](\n            amount,\n            market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": user_account_public_key,\n                    \"authority\": self.authority,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def remove_liquidity(self, amount: int, market_index: int, user_id: int = 0):\n\"\"\"burns LP tokens and removes liquidity to the DAMM\n\n        Args:\n            amount (int): amount of lp tokens to burn\n            market_index (int):\n            user_id (int, optional): subaccount id. Defaults to 0.\n\n        Returns:\n            str: tx sig\n        \"\"\"\n        return await self.send_ixs(\n            [await self.get_remove_liquidity_ix(amount, market_index, user_id)]\n        )\n\n    async def get_remove_liquidity_ix(\n        self, amount: int, market_index: int, user_id: int = 0\n    ):\n        remaining_accounts = await self.get_remaining_accounts(\n            writable_market_index=market_index, user_id=user_id\n        )\n        user_account_public_key = self.get_user_account_public_key(user_id)\n\n        return self.program.instruction[\"remove_perp_lp_shares\"](\n            amount,\n            market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": get_state_public_key(self.program_id),\n                    \"user\": user_account_public_key,\n                    \"authority\": self.authority,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def cancel_orders(self, user_id: int = 0):\n\"\"\"cancel all existing orders on the book\n\n        Args:\n            user_id (int, optional): subaccount id. Defaults to 0.\n\n        Returns:\n            str: tx sig\n        \"\"\"\n        return await self.send_ixs(await self.get_cancel_orders_ix(user_id))\n\n    async def get_cancel_orders_ix(self, user_id: int = 0):\n        remaining_accounts = await self.get_remaining_accounts(user_id=user_id)\n\n        return self.program.instruction[\"cancel_orders\"](\n            None,\n            None,\n            None,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": self.get_user_account_public_key(user_id),\n                    \"authority\": self.authority,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def cancel_order(\n        self,\n        order_id: Optional[int] = None,\n        user_id: int = 0,\n    ):\n\"\"\"cancel specific order (if order_id=None will be most recent order)\n\n        Args:\n            order_id (Optional[int], optional): Defaults to None.\n            user_id (int, optional): subaccount id which contains order. Defaults to 0.\n\n        Returns:\n            str: tx sig\n        \"\"\"\n        return await self.send_ixs(\n            await self.get_cancel_order_ix(order_id, user_id),\n        )\n\n    async def get_cancel_order_ix(\n        self, order_id: Optional[int] = None, user_id: int = 0\n    ):\n        remaining_accounts = await self.get_remaining_accounts(user_id=user_id)\n\n        return self.program.instruction[\"cancel_order\"](\n            order_id,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": self.get_user_account_public_key(user_id),\n                    \"authority\": self.authority,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def open_position(\n        self,\n        direction: PositionDirection,\n        amount: int,\n        market_index: int,\n        user_id: int = 0,\n        limit_price: int = 0,\n        ioc: bool = False,\n    ):\n        return await self.send_ixs(\n            await self.get_open_position_ix(\n                direction,\n                amount,\n                market_index,\n                user_id,\n                limit_price,\n                ioc,\n            ),\n        )\n\n    async def get_open_position_ix(\n        self,\n        direction: PositionDirection,\n        amount: int,\n        market_index: int,\n        user_id: int = 0,\n        limit_price: int = 0,\n        ioc: bool = False,\n    ):\n        order = self.default_order_params(\n            order_type=OrderType.MARKET(),\n            direction=direction,\n            market_index=market_index,\n            base_asset_amount=amount,\n        )\n        order.limit_price = limit_price\n\n        ix = await self.get_place_and_take_ix(order, subaccount_id=user_id)\n        return ix\n\n    def get_increase_compute_ix(self) -&gt; TransactionInstruction:\n        program_id = PublicKey(\"ComputeBudget111111111111111111111111111111\")\n\n        name_bytes = bytearray(1 + 4 + 4)\n        pack_into(\"B\", name_bytes, 0, 0)\n        pack_into(\"I\", name_bytes, 1, 500_000)\n        pack_into(\"I\", name_bytes, 5, 0)\n        data = bytes(name_bytes)\n\n        compute_ix = TransactionInstruction([], program_id, data)\n\n        return compute_ix\n\n    async def place_spot_order(\n        self,\n        order_params: OrderParams,\n        maker_info: MakerInfo = None,\n        user_id: int = 0,\n    ):\n        return await self.send_ixs(\n            [\n                self.get_increase_compute_ix(),\n                await self.get_place_spot_order_ix(order_params, maker_info, user_id),\n            ]\n        )\n\n    async def get_place_spot_order_ix(\n        self,\n        order_params: OrderParams,\n        user_id: int = 0,\n    ):\n        user_account_public_key = self.get_user_account_public_key(user_id)\n\n        remaining_accounts = await self.get_remaining_accounts(\n            readable_spot_market_index=[0, order_params.market_index], user_id=user_id\n        )\n\n        ix = self.program.instruction[\"place_spot_order\"](\n            order_params,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": user_account_public_key,\n                    \"authority\": self.signer.public_key,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n        return ix\n\n    async def get_place_spot_orders_ix(\n        self,\n        order_params: List[OrderParams],\n        user_id: int = 0,\n    ):\n        user_account_public_key = self.get_user_account_public_key(user_id)\n\n        remaining_accounts = await self.get_remaining_accounts(\n            writable_market_index=order_params[0].market_index, user_id=user_id\n        )\n\n        ixs = [\n            self.program.instruction[\"cancel_orders\"](\n                None,\n                None,\n                None,\n                ctx=Context(\n                    accounts={\n                        \"state\": self.get_state_public_key(),\n                        \"user\": self.get_user_account_public_key(user_id),\n                        \"authority\": self.signer.public_key,\n                    },\n                    remaining_accounts=remaining_accounts,\n                ),\n            )\n        ]\n        for order_param in order_params:\n            ix = self.program.instruction[\"place_spot_order\"](\n                order_param,\n                ctx=Context(\n                    accounts={\n                        \"state\": self.get_state_public_key(),\n                        \"user\": user_account_public_key,\n                        \"authority\": self.signer.public_key,\n                    },\n                    remaining_accounts=remaining_accounts,\n                ),\n            )\n            ixs.append(ix)\n\n        return ixs\n\n    async def place_perp_order(\n        self,\n        order_params: OrderParams,\n        maker_info: MakerInfo = None,\n        user_id: int = 0,\n    ):\n        return await self.send_ixs(\n            [\n                self.get_increase_compute_ix(),\n                await self.get_place_perp_order_ix(order_params, maker_info, user_id),\n            ]\n        )\n\n    async def get_place_perp_order_ix(\n        self,\n        order_params: OrderParams,\n        user_id: int = 0,\n    ):\n        user_account_public_key = self.get_user_account_public_key(user_id)\n        remaining_accounts = await self.get_remaining_accounts(\n            writable_market_index=order_params.market_index, user_id=user_id\n        )\n\n        ix = self.program.instruction[\"place_perp_order\"](\n            order_params,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": user_account_public_key,\n                    \"authority\": self.signer.public_key,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n        return ix\n\n    async def get_place_perp_orders_ix(\n        self,\n        order_params: List[OrderParams],\n        user_id: int = 0,\n    ):\n        user_account_public_key = self.get_user_account_public_key(user_id)\n        writeable_market_indexes = list(set([x.market_index for x in order_params]))\n        remaining_accounts = await self.get_remaining_accounts(\n            writable_market_index=writeable_market_indexes, user_id=user_id\n        )\n\n        ixs = [\n            self.program.instruction[\"cancel_orders\"](\n                None,\n                None,\n                None,\n                ctx=Context(\n                    accounts={\n                        \"state\": self.get_state_public_key(),\n                        \"user\": self.get_user_account_public_key(user_id),\n                        \"authority\": self.signer.public_key,\n                    },\n                    remaining_accounts=remaining_accounts,\n                ),\n            )\n        ]\n        for order_param in order_params:\n            ix = self.program.instruction[\"place_perp_order\"](\n                order_param,\n                ctx=Context(\n                    accounts={\n                        \"state\": self.get_state_public_key(),\n                        \"user\": user_account_public_key,\n                        \"authority\": self.signer.public_key,\n                    },\n                    remaining_accounts=remaining_accounts,\n                ),\n            )\n            ixs.append(ix)\n\n        return ixs\n\n    async def place_and_take(\n        self,\n        order_params: OrderParams,\n        maker_info: MakerInfo = None,\n        subaccount_id: int = 0,\n    ):\n        return await self.send_ixs(\n            [\n                self.get_increase_compute_ix(),\n                await self.get_place_and_take_ix(\n                    order_params, maker_info, subaccount_id\n                ),\n            ]\n        )\n\n    async def get_place_and_take_ix(\n        self,\n        order_params: OrderParams,\n        maker_info: MakerInfo = None,\n        subaccount_id: int = 0,\n    ):\n        user_account_public_key = self.get_user_account_public_key(subaccount_id)\n\n        remaining_accounts = await self.get_remaining_accounts(\n            writable_market_index=order_params.market_index,\n            writable_spot_market_index=QUOTE_ASSET_BANK_INDEX,\n            user_id=subaccount_id,\n        )\n\n        maker_order_id = None\n        if maker_info is not None:\n            maker_order_id = maker_info.order.order_id\n            remaining_accounts.append(\n                AccountMeta(pubkey=maker_info.maker, is_signer=False, is_writable=True)\n            )\n\n        return self.program.instruction[\"place_and_take_perp_order\"](\n            order_params,\n            maker_order_id,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": user_account_public_key,\n                    \"user_stats\": self.get_user_stats_public_key(),\n                    \"authority\": self.authority,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def settle_lp(\n        self,\n        settlee_authority: PublicKey,\n        market_index: int,\n        user_id: int = 0,\n    ):\n        return await self.send_ixs(\n            [await self.get_settle_lp_ix(settlee_authority, market_index, user_id)],\n            signers=[],\n        )\n\n    async def get_settle_lp_ix(\n        self, settlee_authority: PublicKey, market_index: int, user_id: int = 0\n    ):\n        remaining_accounts = await self.get_remaining_accounts(\n            writable_market_index=market_index,\n            authority=settlee_authority,\n            user_id=user_id,\n        )\n\n        return self.program.instruction[\"settle_lp\"](\n            market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": get_user_account_public_key(\n                        self.program_id, settlee_authority, user_id\n                    ),\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def get_user_spot_position(\n        self,\n        market_index: int,\n        user_id: int = 0,\n    ) -&gt; Optional[SpotPosition]:\n        user = await get_user_account(self.program, self.authority, user_id)\n\n        found = False\n        for position in user.spot_positions:\n            if (\n                position.market_index == market_index\n                and not is_spot_position_available(position)\n            ):\n                found = True\n                break\n\n        if not found:\n            return None\n\n        return position\n\n    async def get_user_position(\n        self,\n        market_index: int,\n        subaccount_id: int = 0,\n    ) -&gt; Optional[PerpPosition]:\n        user = await get_user_account(self.program, self.authority, subaccount_id)\n\n        found = False\n        for position in user.perp_positions:\n            if position.market_index == market_index and not is_available(position):\n                found = True\n                break\n\n        if not found:\n            return None\n\n        return position\n\n    async def close_position(\n        self, market_index: int, limit_price: int = 0, subaccount_id: int = 0\n    ):\n        return await self.send_ixs(\n            await self.get_close_position_ix(\n                market_index, limit_price, subaccount_id=subaccount_id\n            )\n        )\n\n    async def get_close_position_ix(\n        self, market_index: int, limit_price: int = 0, subaccount_id: int = 0\n    ):\n        position = await self.get_user_position(market_index, subaccount_id)\n        if position is None or position.base_asset_amount == 0:\n            print(\"=&gt; user has no position to close...\")\n            return\n\n        order = self.default_order_params(\n            order_type=OrderType.MARKET(),\n            market_index=market_index,\n            base_asset_amount=abs(int(position.base_asset_amount)),\n            direction=PositionDirection.LONG()\n            if position.base_asset_amount &lt; 0\n            else PositionDirection.SHORT(),\n        )\n        order.limit_price = limit_price\n        order.reduce_only = True\n\n        ix = await self.get_place_and_take_ix(order, subaccount_id=subaccount_id)\n        return ix\n\n    def default_order_params(\n        self, order_type, market_index, base_asset_amount, direction\n    ) -&gt; OrderParams:\n        return OrderParams(\n            order_type,\n            market_type=MarketType.PERP(),\n            direction=direction,\n            user_order_id=0,\n            base_asset_amount=base_asset_amount,\n            price=0,\n            market_index=market_index,\n            reduce_only=False,\n            post_only=PostOnlyParams.NONE(),\n            immediate_or_cancel=False,\n            trigger_price=0,\n            trigger_condition=OrderTriggerCondition.ABOVE(),\n            oracle_price_offset=0,\n            auction_duration=None,\n            max_ts=None,\n            auction_start_price=None,\n            auction_end_price=None,\n        )\n\n    async def liquidate_spot(\n        self,\n        user_authority: PublicKey,\n        asset_market_index: int,\n        liability_market_index: int,\n        max_liability_transfer: int,\n        user_subaccount_id: int = 0,\n        liq_subaccount_id: int = 0,\n    ):\n        return await self.send_ixs(\n            [\n                await self.get_liquidate_spot_ix(\n                    user_authority,\n                    asset_market_index,\n                    liability_market_index,\n                    max_liability_transfer,\n                    user_subaccount_id,\n                    liq_subaccount_id,\n                )\n            ]\n        )\n\n    async def get_liquidate_spot_ix(\n        self,\n        user_authority: PublicKey,\n        asset_market_index: int,\n        liability_market_index: int,\n        max_liability_transfer: int,\n        limit_price: int = None,\n        user_subaccount_id: int = 0,\n        liq_subaccount_id: int = 0,\n    ):\n        user_pk = get_user_account_public_key(\n            self.program_id, user_authority, user_id=user_subaccount_id\n        )\n        user_stats_pk = get_user_stats_account_public_key(\n            self.program_id,\n            user_authority,\n        )\n\n        liq_pk = self.get_user_account_public_key(liq_subaccount_id)\n        liq_stats_pk = self.get_user_stats_public_key()\n\n        remaining_accounts = await self.get_remaining_accounts(\n            writable_spot_market_index=[liability_market_index, asset_market_index],\n            authority=[user_authority, self.authority],\n            user_id=[user_subaccount_id, liq_subaccount_id],\n        )\n\n        return self.program.instruction[\"liquidate_spot\"](\n            asset_market_index,\n            liability_market_index,\n            max_liability_transfer,\n            limit_price,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"authority\": self.authority,\n                    \"user\": user_pk,\n                    \"user_stats\": user_stats_pk,\n                    \"liquidator\": liq_pk,\n                    \"liquidator_stats\": liq_stats_pk,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def liquidate_perp(\n        self,\n        user_authority: PublicKey,\n        market_index: int,\n        max_base_asset_amount: int,\n        limit_price: Optional[int] = None,\n        user_subaccount_id: int = 0,\n        liq_subaccount_id: int = 0,\n    ):\n        return await self.send_ixs(\n            [\n                await self.get_liquidate_perp_ix(\n                    user_authority,\n                    market_index,\n                    max_base_asset_amount,\n                    limit_price,\n                    user_subaccount_id,\n                    liq_subaccount_id,\n                )\n            ]\n        )\n\n    async def get_liquidate_perp_ix(\n        self,\n        user_authority: PublicKey,\n        market_index: int,\n        max_base_asset_amount: int,\n        limit_price: Optional[int] = None,\n        user_subaccount_id: int = 0,\n        liq_subaccount_id: int = 0,\n    ):\n        user_pk = get_user_account_public_key(\n            self.program_id, user_authority, user_subaccount_id\n        )\n        user_stats_pk = get_user_stats_account_public_key(\n            self.program_id,\n            user_authority,\n        )\n\n        liq_pk = self.get_user_account_public_key(liq_subaccount_id)\n        liq_stats_pk = self.get_user_stats_public_key()\n\n        remaining_accounts = await self.get_remaining_accounts(\n            writable_market_index=market_index,\n            authority=[user_authority, self.authority],\n            user_id=[user_subaccount_id, liq_subaccount_id],\n        )\n\n        return self.program.instruction[\"liquidate_perp\"](\n            market_index,\n            max_base_asset_amount,\n            limit_price,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"authority\": self.authority,\n                    \"user\": user_pk,\n                    \"user_stats\": user_stats_pk,\n                    \"liquidator\": liq_pk,\n                    \"liquidator_stats\": liq_stats_pk,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def liquidate_perp_pnl_for_deposit(\n        self,\n        user_authority: PublicKey,\n        perp_market_index: int,\n        spot_market_index: int,\n        max_pnl_transfer: int,\n        user_subaccount_id: int = 0,\n        liq_subaccount_id: int = 0,\n    ):\n        return await self.send_ixs(\n            self.get_liquidate_perp_pnl_for_deposit_ix(\n                user_authority,\n                perp_market_index,\n                spot_market_index,\n                max_pnl_transfer,\n                user_subaccount_id,\n                liq_subaccount_id,\n            )\n        )\n\n    async def get_liquidate_perp_pnl_for_deposit_ix(\n        self,\n        user_authority: PublicKey,\n        perp_market_index: int,\n        spot_market_index: int,\n        max_pnl_transfer: int,\n        limit_price: int = None,\n        user_subaccount_id: int = 0,\n        liq_subaccount_id: int = 0,\n    ):\n        user_pk = get_user_account_public_key(\n            self.program_id, user_authority, user_subaccount_id\n        )\n        user_stats_pk = get_user_stats_account_public_key(\n            self.program_id,\n            user_authority,\n        )\n\n        liq_pk = self.get_user_account_public_key(liq_subaccount_id)\n        liq_stats_pk = self.get_user_stats_public_key()\n\n        remaining_accounts = await self.get_remaining_accounts(\n            writable_market_index=perp_market_index,\n            writable_spot_market_index=spot_market_index,\n            authority=[user_authority, self.authority],\n            user_id=[user_subaccount_id, liq_subaccount_id],\n        )\n\n        result = self.program.instruction[\"liquidate_perp_pnl_for_deposit\"](\n            perp_market_index,\n            spot_market_index,\n            max_pnl_transfer,\n            limit_price,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"authority\": self.authority,\n                    \"user\": user_pk,\n                    \"user_stats\": user_stats_pk,\n                    \"liquidator\": liq_pk,\n                    \"liquidator_stats\": liq_stats_pk,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n        return result\n\n    async def settle_pnl(\n        self,\n        user_authority: PublicKey,\n        market_index: int,\n        user_id: int = 0,\n    ):\n        return await self.send_ixs(\n            await self.get_settle_pnl_ix(user_authority, market_index, user_id)\n        )\n\n    async def get_settle_pnl_ix(\n        self,\n        user_authority: PublicKey,\n        market_index: int,\n        user_id: int = 0,\n    ):\n        remaining_accounts = await self.get_remaining_accounts(\n            authority=user_authority,\n            writable_market_index=market_index,\n            writable_spot_market_index=QUOTE_ASSET_BANK_INDEX,\n            user_id=user_id,\n        )\n\n        return [\n            self.get_increase_compute_ix(),\n            self.program.instruction[\"settle_pnl\"](\n                market_index,\n                ctx=Context(\n                    accounts={\n                        \"state\": self.get_state_public_key(),\n                        \"authority\": self.authority,\n                        \"user\": get_user_account_public_key(\n                            self.program_id, user_authority, user_id\n                        ),\n                        \"spot_market_vault\": get_spot_market_vault_public_key(\n                            self.program_id, QUOTE_ASSET_BANK_INDEX\n                        ),\n                    },\n                    remaining_accounts=remaining_accounts,\n                ),\n            ),\n        ]\n\n    async def resolve_spot_bankruptcy(\n        self,\n        user_authority: PublicKey,\n        spot_market_index: int,\n        user_subaccount_id: int = 0,\n        liq_subaccount_id: int = 0,\n    ):\n        return await self.send_ixs(\n            [\n                await self.get_resolve_spot_bankruptcy_ix(\n                    user_authority,\n                    spot_market_index,\n                    user_subaccount_id,\n                    liq_subaccount_id,\n                )\n            ]\n        )\n\n    async def get_resolve_spot_bankruptcy_ix(\n        self,\n        user_authority: PublicKey,\n        spot_market_index: int,\n        user_subaccount_id: int = 0,\n        liq_subaccount_id: int = 0,\n    ):\n        user_pk = get_user_account_public_key(\n            self.program_id, user_authority, user_subaccount_id\n        )\n        user_stats_pk = get_user_stats_account_public_key(\n            self.program_id,\n            user_authority,\n        )\n\n        liq_pk = self.get_user_account_public_key(liq_subaccount_id)\n        liq_stats_pk = self.get_user_stats_public_key()\n\n        remaining_accounts = await self.get_remaining_accounts(\n            writable_spot_market_index=spot_market_index,\n            authority=[user_authority, self.authority],\n            user_id=[user_subaccount_id, liq_subaccount_id],\n        )\n\n        if_vault = get_insurance_fund_vault_public_key(\n            self.program_id, spot_market_index\n        )\n        spot_vault = get_spot_market_vault_public_key(\n            self.program_id, spot_market_index\n        )\n        ch_signer = get_clearing_house_signer_public_key(self.program_id)\n\n        return self.program.instruction[\"resolve_spot_bankruptcy\"](\n            spot_market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"authority\": self.authority,\n                    \"user\": user_pk,\n                    \"user_stats\": user_stats_pk,\n                    \"liquidator\": liq_pk,\n                    \"liquidator_stats\": liq_stats_pk,\n                    \"spot_market_vault\": spot_vault,\n                    \"insurance_fund_vault\": if_vault,\n                    \"drift_signer\": ch_signer,\n                    \"token_program\": TOKEN_PROGRAM_ID,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def resolve_perp_bankruptcy(\n        self,\n        user_authority: PublicKey,\n        market_index: int,\n        user_subaccount_id: int = 0,\n        liq_subaccount_id: int = 0,\n    ):\n        return await self.send_ixs(\n            [\n                await self.get_resolve_perp_bankruptcy_ix(\n                    user_authority,\n                    market_index,\n                    user_subaccount_id,\n                    liq_subaccount_id,\n                )\n            ]\n        )\n\n    async def get_resolve_perp_bankruptcy_ix(\n        self,\n        user_authority: PublicKey,\n        market_index: int,\n        user_subaccount_id: int = 0,\n        liq_subaccount_id: int = 0,\n    ):\n        user_pk = get_user_account_public_key(\n            self.program_id, user_authority, user_subaccount_id\n        )\n        user_stats_pk = get_user_stats_account_public_key(\n            self.program_id,\n            user_authority,\n        )\n\n        liq_pk = self.get_user_account_public_key(liq_subaccount_id)\n        liq_stats_pk = self.get_user_stats_public_key()\n\n        remaining_accounts = await self.get_remaining_accounts(\n            writable_market_index=market_index,\n            writable_spot_market_index=QUOTE_ASSET_BANK_INDEX,\n            authority=[user_authority, self.authority],\n            user_id=[user_subaccount_id, liq_subaccount_id],\n        )\n\n        if_vault = get_insurance_fund_vault_public_key(self.program_id, market_index)\n        spot_vault = get_spot_market_vault_public_key(self.program_id, market_index)\n        ch_signer = get_clearing_house_signer_public_key(self.program_id)\n\n        return self.program.instruction[\"resolve_perp_bankruptcy\"](\n            QUOTE_ASSET_BANK_INDEX,\n            market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"authority\": self.authority,\n                    \"user\": user_pk,\n                    \"user_stats\": user_stats_pk,\n                    \"liquidator\": liq_pk,\n                    \"liquidator_stats\": liq_stats_pk,\n                    \"spot_market_vault\": spot_vault,\n                    \"insurance_fund_vault\": if_vault,\n                    \"drift_signer\": ch_signer,\n                    \"token_program\": TOKEN_PROGRAM_ID,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def settle_expired_market(\n        self,\n        market_index: int,\n    ):\n        return await self.send_ixs(\n            [\n                self.get_increase_compute_ix(),\n                await self.get_settle_expired_market_ix(\n                    market_index,\n                ),\n            ]\n        )\n\n    async def get_settle_expired_market_ix(\n        self,\n        market_index: int,\n    ):\n        market = await get_perp_market_account(self.program, market_index)\n\n        market_account_infos = [\n            AccountMeta(\n                pubkey=market.pubkey,\n                is_writable=True,\n                is_signer=False,\n            )\n        ]\n\n        oracle_account_infos = [\n            AccountMeta(\n                pubkey=market.amm.oracle,\n                is_writable=False,\n                is_signer=False,\n            )\n        ]\n\n        spot_pk = get_spot_market_public_key(self.program_id, QUOTE_ASSET_BANK_INDEX)\n        spot_account_infos = [\n            AccountMeta(\n                pubkey=spot_pk,\n                is_writable=True,\n                is_signer=False,\n            )\n        ]\n\n        remaining_accounts = (\n            oracle_account_infos + spot_account_infos + market_account_infos\n        )\n\n        return self.program.instruction[\"settle_expired_market\"](\n            market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"authority\": self.authority,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def request_remove_insurance_fund_stake(\n        self, spot_market_index: int, amount: int\n    ):\n        return await self.send_ixs(\n            await self.get_request_remove_insurance_fund_stake_ix(\n                spot_market_index, amount\n            )\n        )\n\n    async def get_request_remove_insurance_fund_stake_ix(\n        self,\n        spot_market_index: int,\n        amount: int,\n    ):\n        ra = await self.get_remaining_accounts(\n            writable_spot_market_index=spot_market_index,\n            user_id=[],  # dont need the user account (might not exist)\n        )\n\n        return self.program.instruction[\"request_remove_insurance_fund_stake\"](\n            spot_market_index,\n            amount,\n            ctx=Context(\n                accounts={\n                    \"spot_market\": get_spot_market_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"insurance_fund_stake\": get_insurance_fund_stake_public_key(\n                        self.program_id, self.authority, spot_market_index\n                    ),\n                    \"user_stats\": get_user_stats_account_public_key(\n                        self.program_id, self.authority\n                    ),\n                    \"authority\": self.authority,\n                    \"insurance_fund_vault\": get_insurance_fund_vault_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                },\n                remaining_accounts=ra,\n            ),\n        )\n\n    async def cancel_request_remove_insurance_fund_stake(self, spot_market_index: int):\n        return await self.send_ixs(\n            await self.get_cancel_request_remove_insurance_fund_stake_ix(\n                spot_market_index\n            )\n        )\n\n    async def get_cancel_request_remove_insurance_fund_stake_ix(\n        self, spot_market_index: int\n    ):\n        ra = await self.get_remaining_accounts(\n            writable_spot_market_index=spot_market_index\n        )\n\n        return self.program.instruction[\"cancel_request_remove_insurance_fund_stake\"](\n            spot_market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": get_state_public_key(self.program_id),\n                    \"spot_market\": get_spot_market_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"insurance_fund_stake\": get_insurance_fund_stake_public_key(\n                        self.program_id, self.authority, spot_market_index\n                    ),\n                    \"user_stats\": get_user_stats_account_public_key(\n                        self.program_id, self.authority\n                    ),\n                    \"authority\": self.authority,\n                    \"insurance_fund_vault\": get_insurance_fund_vault_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"drift_signer\": get_clearing_house_signer_public_key(\n                        self.program_id\n                    ),\n                    \"user_token_account\": self.spot_market_atas[spot_market_index],\n                    \"token_program\": TOKEN_PROGRAM_ID,\n                },\n                remaining_accounts=ra,\n            ),\n        )\n\n    async def remove_insurance_fund_stake(self, spot_market_index: int):\n        return await self.send_ixs(\n            await self.get_remove_insurance_fund_stake_ix(spot_market_index)\n        )\n\n    async def get_remove_insurance_fund_stake_ix(self, spot_market_index: int):\n        ra = await self.get_remaining_accounts(\n            writable_spot_market_index=spot_market_index,\n            user_id=[],  # dont need the user account (might not exist)\n        )\n\n        return self.program.instruction[\"remove_insurance_fund_stake\"](\n            spot_market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": get_state_public_key(self.program_id),\n                    \"spot_market\": get_spot_market_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"insurance_fund_stake\": get_insurance_fund_stake_public_key(\n                        self.program_id, self.authority, spot_market_index\n                    ),\n                    \"user_stats\": get_user_stats_account_public_key(\n                        self.program_id, self.authority\n                    ),\n                    \"authority\": self.authority,\n                    \"insurance_fund_vault\": get_insurance_fund_vault_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"drift_signer\": get_clearing_house_signer_public_key(\n                        self.program_id\n                    ),\n                    \"user_token_account\": self.spot_market_atas[spot_market_index],\n                    \"token_program\": TOKEN_PROGRAM_ID,\n                },\n                remaining_accounts=ra,\n            ),\n        )\n\n    async def add_insurance_fund_stake(self, spot_market_index: int, amount: int):\n        return await self.send_ixs(\n            await self.get_add_insurance_fund_stake_ix(spot_market_index, amount)\n        )\n\n    async def get_add_insurance_fund_stake_ix(\n        self,\n        spot_market_index: int,\n        amount: int,\n    ):\n        remaining_accounts = await self.get_remaining_accounts(\n            writable_spot_market_index=spot_market_index,\n        )\n\n        assert (\n            self.spot_market_atas[spot_market_index] is not None\n        ), \"please set self.spot_market_atas[spot_market_index] as your spot ata pubkey before this ix\"\n\n        return self.program.instruction[\"add_insurance_fund_stake\"](\n            spot_market_index,\n            amount,\n            ctx=Context(\n                accounts={\n                    \"state\": get_state_public_key(self.program_id),\n                    \"spot_market\": get_spot_market_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"insurance_fund_stake\": get_insurance_fund_stake_public_key(\n                        self.program_id, self.authority, spot_market_index\n                    ),\n                    \"user_stats\": get_user_stats_account_public_key(\n                        self.program_id, self.authority\n                    ),\n                    \"authority\": self.authority,\n                    \"spot_market_vault\": get_spot_market_vault_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"insurance_fund_vault\": get_insurance_fund_vault_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"drift_signer\": get_clearing_house_signer_public_key(\n                        self.program_id\n                    ),\n                    \"user_token_account\": self.spot_market_atas[spot_market_index],\n                    \"token_program\": TOKEN_PROGRAM_ID,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def initialize_insurance_fund_stake(\n        self,\n        spot_market_index: int,\n    ):\n        return await self.send_ixs(\n            self.get_initialize_insurance_fund_stake_ix(spot_market_index)\n        )\n\n    def get_initialize_insurance_fund_stake_ix(\n        self,\n        spot_market_index: int,\n    ):\n        return self.program.instruction[\"initialize_insurance_fund_stake\"](\n            spot_market_index,\n            ctx=Context(\n                accounts={\n                    \"spot_market\": get_spot_market_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"insurance_fund_stake\": get_insurance_fund_stake_public_key(\n                        self.program_id, self.authority, spot_market_index\n                    ),\n                    \"user_stats\": get_user_stats_account_public_key(\n                        self.program_id, self.authority\n                    ),\n                    \"state\": get_state_public_key(self.program_id),\n                    \"authority\": self.authority,\n                    \"payer\": self.authority,\n                    \"rent\": SYSVAR_RENT_PUBKEY,\n                    \"system_program\": SYS_PROGRAM_ID,\n                }\n            ),\n        )\n\n    async def update_amm(self, market_indexs: list[int]):\n        return await self.send_ixs(await self.get_update_amm_ix(market_indexs))\n\n    async def get_update_amm_ix(\n        self,\n        market_indexs: list[int],\n    ):\n        n = len(market_indexs)\n        for _ in range(5 - n):\n            market_indexs.append(100)\n\n        market_infos = []\n        oracle_infos = []\n        for idx in market_indexs:\n            if idx != 100:\n                market = await get_perp_market_account(self.program, idx)\n                market_infos.append(\n                    AccountMeta(\n                        pubkey=market.pubkey,\n                        is_signer=False,\n                        is_writable=True,\n                    )\n                )\n                oracle_infos.append(\n                    AccountMeta(\n                        pubkey=market.amm.oracle, is_signer=False, is_writable=False\n                    )\n                )\n\n        remaining_accounts = oracle_infos + market_infos\n\n        return self.program.instruction[\"update_amms\"](\n            market_indexs,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"authority\": self.authority,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n\n    async def settle_revenue_to_insurance_fund(self, spot_market_index: int):\n        return await self.program.rpc[\"settle_revenue_to_insurance_fund\"](\n            spot_market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": get_state_public_key(self.program_id),\n                    \"spot_market\": get_spot_market_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"spot_market_vault\": get_spot_market_vault_public_key(\n                        self.program_id, spot_market_index\n                    ),\n                    \"drift_signer\": get_clearing_house_signer_public_key(\n                        self.program_id\n                    ),\n                    \"insurance_fund_vault\": get_insurance_fund_vault_public_key(\n                        self.program_id,\n                        spot_market_index,\n                    ),\n                    \"token_program\": TOKEN_PROGRAM_ID,\n                }\n            ),\n        )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.authority","title":"<code>authority = authority</code>  <code>instance-attribute</code>","text":""},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.program","title":"<code>program = program</code>  <code>instance-attribute</code>","text":""},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.program_id","title":"<code>program_id = program.program_id</code>  <code>instance-attribute</code>","text":""},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.signer","title":"<code>signer = signer</code>  <code>instance-attribute</code>","text":""},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.signers","title":"<code>signers = [self.signer]</code>  <code>instance-attribute</code>","text":""},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.spot_market_atas","title":"<code>spot_market_atas = {}</code>  <code>instance-attribute</code>","text":""},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.subaccounts","title":"<code>subaccounts = [0]</code>  <code>instance-attribute</code>","text":""},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.usdc_ata","title":"<code>usdc_ata = None</code>  <code>instance-attribute</code>","text":""},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.user_index","title":"<code>user_index = None</code>  <code>instance-attribute</code>","text":""},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.__init__","title":"<code>__init__(program, signer=None, authority=None)</code>","text":"<p>Initializes the clearing house object -- likely want to use the .from_config method instead of this one</p> <p>Parameters:</p> Name Type Description Default <code>program</code> <code>Program</code> <p>Drift anchor program (see from_config on how to initialize it)</p> required <code>authority</code> <code>Keypair</code> <p>Authority of all txs - if None will default to the Anchor Provider.Wallet Keypair.</p> <code>None</code> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>def __init__(self, program: Program, signer: Keypair = None, authority: PublicKey = None):\n\"\"\"Initializes the clearing house object -- likely want to use the .from_config method instead of this one\n\n    Args:\n        program (Program): Drift anchor program (see from_config on how to initialize it)\n        authority (Keypair, optional): Authority of all txs - if None will default to the Anchor Provider.Wallet Keypair.\n    \"\"\"\n    self.program = program\n    self.program_id = program.program_id\n    self.user_index = None\n\n    if signer is None:\n        signer = program.provider.wallet.payer\n\n    self.signer = signer\n    self.authority = authority\n    self.signers = [self.signer]\n    self.usdc_ata = None\n    self.spot_market_atas = {}\n    self.subaccounts = [0]\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.add_insurance_fund_stake","title":"<code>add_insurance_fund_stake(spot_market_index, amount)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def add_insurance_fund_stake(self, spot_market_index: int, amount: int):\n    return await self.send_ixs(\n        await self.get_add_insurance_fund_stake_ix(spot_market_index, amount)\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.add_liquidity","title":"<code>add_liquidity(amount, market_index, user_id=0)</code>  <code>async</code>","text":"<p>mint LP tokens and add liquidity to the DAMM</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>amount of lp tokens to mint</p> required <code>market_index</code> <code>int</code> <p>market you want to lp in</p> required <code>user_id</code> <code>int</code> <p>subaccount id. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>str</code> <p>tx sig</p> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def add_liquidity(self, amount: int, market_index: int, user_id: int = 0):\n\"\"\"mint LP tokens and add liquidity to the DAMM\n\n    Args:\n        amount (int): amount of lp tokens to mint\n        market_index (int): market you want to lp in\n        user_id (int, optional): subaccount id. Defaults to 0.\n\n    Returns:\n        str: tx sig\n    \"\"\"\n    return await self.send_ixs(\n        [await self.get_add_liquidity_ix(amount, market_index, user_id)]\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.cancel_order","title":"<code>cancel_order(order_id=None, user_id=0)</code>  <code>async</code>","text":"<p>cancel specific order (if order_id=None will be most recent order)</p> <p>Parameters:</p> Name Type Description Default <code>order_id</code> <code>Optional[int]</code> <p>Defaults to None.</p> <code>None</code> <code>user_id</code> <code>int</code> <p>subaccount id which contains order. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>str</code> <p>tx sig</p> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def cancel_order(\n    self,\n    order_id: Optional[int] = None,\n    user_id: int = 0,\n):\n\"\"\"cancel specific order (if order_id=None will be most recent order)\n\n    Args:\n        order_id (Optional[int], optional): Defaults to None.\n        user_id (int, optional): subaccount id which contains order. Defaults to 0.\n\n    Returns:\n        str: tx sig\n    \"\"\"\n    return await self.send_ixs(\n        await self.get_cancel_order_ix(order_id, user_id),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.cancel_orders","title":"<code>cancel_orders(user_id=0)</code>  <code>async</code>","text":"<p>cancel all existing orders on the book</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>subaccount id. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>str</code> <p>tx sig</p> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def cancel_orders(self, user_id: int = 0):\n\"\"\"cancel all existing orders on the book\n\n    Args:\n        user_id (int, optional): subaccount id. Defaults to 0.\n\n    Returns:\n        str: tx sig\n    \"\"\"\n    return await self.send_ixs(await self.get_cancel_orders_ix(user_id))\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.cancel_request_remove_insurance_fund_stake","title":"<code>cancel_request_remove_insurance_fund_stake(spot_market_index)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def cancel_request_remove_insurance_fund_stake(self, spot_market_index: int):\n    return await self.send_ixs(\n        await self.get_cancel_request_remove_insurance_fund_stake_ix(\n            spot_market_index\n        )\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.close_position","title":"<code>close_position(market_index, limit_price=0, subaccount_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def close_position(\n    self, market_index: int, limit_price: int = 0, subaccount_id: int = 0\n):\n    return await self.send_ixs(\n        await self.get_close_position_ix(\n            market_index, limit_price, subaccount_id=subaccount_id\n        )\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.default_order_params","title":"<code>default_order_params(order_type, market_index, base_asset_amount, direction)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>def default_order_params(\n    self, order_type, market_index, base_asset_amount, direction\n) -&gt; OrderParams:\n    return OrderParams(\n        order_type,\n        market_type=MarketType.PERP(),\n        direction=direction,\n        user_order_id=0,\n        base_asset_amount=base_asset_amount,\n        price=0,\n        market_index=market_index,\n        reduce_only=False,\n        post_only=PostOnlyParams.NONE(),\n        immediate_or_cancel=False,\n        trigger_price=0,\n        trigger_condition=OrderTriggerCondition.ABOVE(),\n        oracle_price_offset=0,\n        auction_duration=None,\n        max_ts=None,\n        auction_start_price=None,\n        auction_end_price=None,\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.deposit","title":"<code>deposit(amount, spot_market_index, user_token_account, user_id=0, reduce_only=False, user_initialized=True)</code>  <code>async</code>","text":"<p>deposits collateral into protocol</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>amount to deposit</p> required <code>spot_market_index</code> <code>int</code> required <code>user_token_account</code> <code>PublicKey</code> required <code>user_id</code> <code>int</code> <p>subaccount to deposit into. Defaults to 0.</p> <code>0</code> <code>reduce_only</code> <code>bool</code> <p>paying back borrow vs depositing new assets. Defaults to False.</p> <code>False</code> <code>user_initialized</code> <code>bool</code> <p>if need to initialize user account too set this to False. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>str</code> <p>sig</p> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def deposit(\n    self,\n    amount: int,\n    spot_market_index: int,\n    user_token_account: PublicKey,\n    user_id: int = 0,\n    reduce_only=False,\n    user_initialized=True,\n):\n\"\"\"deposits collateral into protocol\n\n    Args:\n        amount (int): amount to deposit\n        spot_market_index (int):\n        user_token_account (PublicKey):\n        user_id (int, optional): subaccount to deposit into. Defaults to 0.\n        reduce_only (bool, optional): paying back borrow vs depositing new assets. Defaults to False.\n        user_initialized (bool, optional): if need to initialize user account too set this to False. Defaults to True.\n\n    Returns:\n        str: sig\n    \"\"\"\n    return await self.send_ixs(\n        [\n            await self.get_deposit_collateral_ix(\n                amount,\n                spot_market_index,\n                user_token_account,\n                user_id,\n                reduce_only,\n                user_initialized,\n            )\n        ]\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.from_config","title":"<code>from_config(config, provider, authority=None)</code>  <code>staticmethod</code>","text":"<p>Initializes the clearing house object from a Config</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Config</code> <p>the config to initialize form</p> required <code>provider</code> <code>Provider</code> <p>anchor provider</p> required <code>authority</code> <code>Keypair</code> <p>description. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>ClearingHouse</code> <p>the clearing house object</p> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>@staticmethod\ndef from_config(config: Config, provider: Provider, authority: Keypair = None):\n\"\"\"Initializes the clearing house object from a Config\n\n    Args:\n        config (Config): the config to initialize form\n        provider (Provider): anchor provider\n        authority (Keypair, optional):  _description_. Defaults to None.\n\n    Returns:\n        ClearingHouse: the clearing house object\n    \"\"\"\n    # read the idl\n    file = Path(str(driftpy.__path__[0]) + \"/idl/drift.json\")\n    print(file)\n    with file.open() as f:\n        idl_dict = json.load(f)\n    idl = Idl.from_json(idl_dict)\n\n    # create the program\n    program = Program(\n        idl,\n        config.clearing_house_program_id,\n        provider,\n    )\n\n    clearing_house = ClearingHouse(program, authority)\n    clearing_house.config = config\n    clearing_house.idl = idl\n\n    return clearing_house\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_add_insurance_fund_stake_ix","title":"<code>get_add_insurance_fund_stake_ix(spot_market_index, amount)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_add_insurance_fund_stake_ix(\n    self,\n    spot_market_index: int,\n    amount: int,\n):\n    remaining_accounts = await self.get_remaining_accounts(\n        writable_spot_market_index=spot_market_index,\n    )\n\n    assert (\n        self.spot_market_atas[spot_market_index] is not None\n    ), \"please set self.spot_market_atas[spot_market_index] as your spot ata pubkey before this ix\"\n\n    return self.program.instruction[\"add_insurance_fund_stake\"](\n        spot_market_index,\n        amount,\n        ctx=Context(\n            accounts={\n                \"state\": get_state_public_key(self.program_id),\n                \"spot_market\": get_spot_market_public_key(\n                    self.program_id, spot_market_index\n                ),\n                \"insurance_fund_stake\": get_insurance_fund_stake_public_key(\n                    self.program_id, self.authority, spot_market_index\n                ),\n                \"user_stats\": get_user_stats_account_public_key(\n                    self.program_id, self.authority\n                ),\n                \"authority\": self.authority,\n                \"spot_market_vault\": get_spot_market_vault_public_key(\n                    self.program_id, spot_market_index\n                ),\n                \"insurance_fund_vault\": get_insurance_fund_vault_public_key(\n                    self.program_id, spot_market_index\n                ),\n                \"drift_signer\": get_clearing_house_signer_public_key(\n                    self.program_id\n                ),\n                \"user_token_account\": self.spot_market_atas[spot_market_index],\n                \"token_program\": TOKEN_PROGRAM_ID,\n            },\n            remaining_accounts=remaining_accounts,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_add_liquidity_ix","title":"<code>get_add_liquidity_ix(amount, market_index, user_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_add_liquidity_ix(\n    self, amount: int, market_index: int, user_id: int = 0\n):\n    remaining_accounts = await self.get_remaining_accounts(\n        writable_market_index=market_index, user_id=user_id\n    )\n    user_account_public_key = get_user_account_public_key(\n        self.program_id, self.authority, user_id\n    )\n\n    return self.program.instruction[\"add_perp_lp_shares\"](\n        amount,\n        market_index,\n        ctx=Context(\n            accounts={\n                \"state\": self.get_state_public_key(),\n                \"user\": user_account_public_key,\n                \"authority\": self.authority,\n            },\n            remaining_accounts=remaining_accounts,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_cancel_order_ix","title":"<code>get_cancel_order_ix(order_id=None, user_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_cancel_order_ix(\n    self, order_id: Optional[int] = None, user_id: int = 0\n):\n    remaining_accounts = await self.get_remaining_accounts(user_id=user_id)\n\n    return self.program.instruction[\"cancel_order\"](\n        order_id,\n        ctx=Context(\n            accounts={\n                \"state\": self.get_state_public_key(),\n                \"user\": self.get_user_account_public_key(user_id),\n                \"authority\": self.authority,\n            },\n            remaining_accounts=remaining_accounts,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_cancel_orders_ix","title":"<code>get_cancel_orders_ix(user_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_cancel_orders_ix(self, user_id: int = 0):\n    remaining_accounts = await self.get_remaining_accounts(user_id=user_id)\n\n    return self.program.instruction[\"cancel_orders\"](\n        None,\n        None,\n        None,\n        ctx=Context(\n            accounts={\n                \"state\": self.get_state_public_key(),\n                \"user\": self.get_user_account_public_key(user_id),\n                \"authority\": self.authority,\n            },\n            remaining_accounts=remaining_accounts,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_cancel_request_remove_insurance_fund_stake_ix","title":"<code>get_cancel_request_remove_insurance_fund_stake_ix(spot_market_index)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_cancel_request_remove_insurance_fund_stake_ix(\n    self, spot_market_index: int\n):\n    ra = await self.get_remaining_accounts(\n        writable_spot_market_index=spot_market_index\n    )\n\n    return self.program.instruction[\"cancel_request_remove_insurance_fund_stake\"](\n        spot_market_index,\n        ctx=Context(\n            accounts={\n                \"state\": get_state_public_key(self.program_id),\n                \"spot_market\": get_spot_market_public_key(\n                    self.program_id, spot_market_index\n                ),\n                \"insurance_fund_stake\": get_insurance_fund_stake_public_key(\n                    self.program_id, self.authority, spot_market_index\n                ),\n                \"user_stats\": get_user_stats_account_public_key(\n                    self.program_id, self.authority\n                ),\n                \"authority\": self.authority,\n                \"insurance_fund_vault\": get_insurance_fund_vault_public_key(\n                    self.program_id, spot_market_index\n                ),\n                \"drift_signer\": get_clearing_house_signer_public_key(\n                    self.program_id\n                ),\n                \"user_token_account\": self.spot_market_atas[spot_market_index],\n                \"token_program\": TOKEN_PROGRAM_ID,\n            },\n            remaining_accounts=ra,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_close_position_ix","title":"<code>get_close_position_ix(market_index, limit_price=0, subaccount_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_close_position_ix(\n    self, market_index: int, limit_price: int = 0, subaccount_id: int = 0\n):\n    position = await self.get_user_position(market_index, subaccount_id)\n    if position is None or position.base_asset_amount == 0:\n        print(\"=&gt; user has no position to close...\")\n        return\n\n    order = self.default_order_params(\n        order_type=OrderType.MARKET(),\n        market_index=market_index,\n        base_asset_amount=abs(int(position.base_asset_amount)),\n        direction=PositionDirection.LONG()\n        if position.base_asset_amount &lt; 0\n        else PositionDirection.SHORT(),\n    )\n    order.limit_price = limit_price\n    order.reduce_only = True\n\n    ix = await self.get_place_and_take_ix(order, subaccount_id=subaccount_id)\n    return ix\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_deposit_collateral_ix","title":"<code>get_deposit_collateral_ix(amount, spot_market_index, user_token_account, user_id=0, reduce_only=False, user_initialized=True)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_deposit_collateral_ix(\n    self,\n    amount: int,\n    spot_market_index: int,\n    user_token_account: PublicKey,\n    user_id: int = 0,\n    reduce_only=False,\n    user_initialized=True,\n) -&gt; TransactionInstruction:\n    if user_initialized:\n        remaining_accounts = await self.get_remaining_accounts(\n            writable_spot_market_index=spot_market_index, user_id=user_id\n        )\n    else:\n        raise Exception(\"not implemented...\")\n\n    spot_market_pk = get_spot_market_public_key(self.program_id, spot_market_index)\n    spot_vault_public_key = get_spot_market_vault_public_key(\n        self.program_id, spot_market_index\n    )\n    user_account_public_key = get_user_account_public_key(\n        self.program_id, self.authority, user_id\n    )\n    return self.program.instruction[\"deposit\"](\n        spot_market_index,\n        amount,\n        reduce_only,\n        ctx=Context(\n            accounts={\n                \"state\": self.get_state_public_key(),\n                \"spot_market\": spot_market_pk,\n                \"spot_market_vault\": spot_vault_public_key,\n                \"user\": user_account_public_key,\n                \"user_stats\": self.get_user_stats_public_key(),\n                \"user_token_account\": user_token_account,\n                \"authority\": self.authority,\n                \"token_program\": TOKEN_PROGRAM_ID,\n            },\n            remaining_accounts=remaining_accounts,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_increase_compute_ix","title":"<code>get_increase_compute_ix()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>def get_increase_compute_ix(self) -&gt; TransactionInstruction:\n    program_id = PublicKey(\"ComputeBudget111111111111111111111111111111\")\n\n    name_bytes = bytearray(1 + 4 + 4)\n    pack_into(\"B\", name_bytes, 0, 0)\n    pack_into(\"I\", name_bytes, 1, 500_000)\n    pack_into(\"I\", name_bytes, 5, 0)\n    data = bytes(name_bytes)\n\n    compute_ix = TransactionInstruction([], program_id, data)\n\n    return compute_ix\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_initialize_insurance_fund_stake_ix","title":"<code>get_initialize_insurance_fund_stake_ix(spot_market_index)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>def get_initialize_insurance_fund_stake_ix(\n    self,\n    spot_market_index: int,\n):\n    return self.program.instruction[\"initialize_insurance_fund_stake\"](\n        spot_market_index,\n        ctx=Context(\n            accounts={\n                \"spot_market\": get_spot_market_public_key(\n                    self.program_id, spot_market_index\n                ),\n                \"insurance_fund_stake\": get_insurance_fund_stake_public_key(\n                    self.program_id, self.authority, spot_market_index\n                ),\n                \"user_stats\": get_user_stats_account_public_key(\n                    self.program_id, self.authority\n                ),\n                \"state\": get_state_public_key(self.program_id),\n                \"authority\": self.authority,\n                \"payer\": self.authority,\n                \"rent\": SYSVAR_RENT_PUBKEY,\n                \"system_program\": SYS_PROGRAM_ID,\n            }\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_initialize_user_instructions","title":"<code>get_initialize_user_instructions(user_id=0, name=DEFAULT_USER_NAME)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>def get_initialize_user_instructions(\n    self, user_id: int = 0, name: str = DEFAULT_USER_NAME\n) -&gt; TransactionInstruction:\n    user_public_key = self.get_user_account_public_key(user_id)\n    state_public_key = self.get_state_public_key()\n    user_stats_public_key = self.get_user_stats_public_key()\n\n    if len(name) &gt; 32:\n        raise Exception(\"name too long\")\n\n    name_bytes = bytearray(32)\n    pack_into(f\"{len(name)}s\", name_bytes, 0, name.encode(\"utf-8\"))\n    offset = len(name)\n    for _ in range(32 - len(name)):\n        pack_into(\"1s\", name_bytes, offset, \" \".encode(\"utf-8\"))\n        offset += 1\n\n    str_name_bytes = name_bytes.hex()\n    name_byte_array = []\n    for i in range(0, len(str_name_bytes), 2):\n        name_byte_array.append(int(str_name_bytes[i : i + 2], 16))\n\n    initialize_user_account_ix = self.program.instruction[\"initialize_user\"](\n        user_id,\n        name_byte_array,\n        ctx=Context(\n            accounts={\n                \"user\": user_public_key,\n                \"user_stats\": user_stats_public_key,\n                \"state\": state_public_key,\n                \"authority\": self.authority,\n                \"payer\": self.authority,\n                \"rent\": SYSVAR_RENT_PUBKEY,\n                \"system_program\": SYS_PROGRAM_ID,\n            },\n        ),\n    )\n    return initialize_user_account_ix\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_initialize_user_stats","title":"<code>get_initialize_user_stats()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>def get_initialize_user_stats(\n    self,\n):\n    state_public_key = self.get_state_public_key()\n    user_stats_public_key = self.get_user_stats_public_key()\n\n    return self.program.instruction[\"initialize_user_stats\"](\n        ctx=Context(\n            accounts={\n                \"user_stats\": user_stats_public_key,\n                \"state\": state_public_key,\n                \"authority\": self.authority,\n                \"payer\": self.authority,\n                \"rent\": SYSVAR_RENT_PUBKEY,\n                \"system_program\": SYS_PROGRAM_ID,\n            },\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_liquidate_perp_ix","title":"<code>get_liquidate_perp_ix(user_authority, market_index, max_base_asset_amount, limit_price=None, user_subaccount_id=0, liq_subaccount_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_liquidate_perp_ix(\n    self,\n    user_authority: PublicKey,\n    market_index: int,\n    max_base_asset_amount: int,\n    limit_price: Optional[int] = None,\n    user_subaccount_id: int = 0,\n    liq_subaccount_id: int = 0,\n):\n    user_pk = get_user_account_public_key(\n        self.program_id, user_authority, user_subaccount_id\n    )\n    user_stats_pk = get_user_stats_account_public_key(\n        self.program_id,\n        user_authority,\n    )\n\n    liq_pk = self.get_user_account_public_key(liq_subaccount_id)\n    liq_stats_pk = self.get_user_stats_public_key()\n\n    remaining_accounts = await self.get_remaining_accounts(\n        writable_market_index=market_index,\n        authority=[user_authority, self.authority],\n        user_id=[user_subaccount_id, liq_subaccount_id],\n    )\n\n    return self.program.instruction[\"liquidate_perp\"](\n        market_index,\n        max_base_asset_amount,\n        limit_price,\n        ctx=Context(\n            accounts={\n                \"state\": self.get_state_public_key(),\n                \"authority\": self.authority,\n                \"user\": user_pk,\n                \"user_stats\": user_stats_pk,\n                \"liquidator\": liq_pk,\n                \"liquidator_stats\": liq_stats_pk,\n            },\n            remaining_accounts=remaining_accounts,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_liquidate_perp_pnl_for_deposit_ix","title":"<code>get_liquidate_perp_pnl_for_deposit_ix(user_authority, perp_market_index, spot_market_index, max_pnl_transfer, limit_price=None, user_subaccount_id=0, liq_subaccount_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_liquidate_perp_pnl_for_deposit_ix(\n    self,\n    user_authority: PublicKey,\n    perp_market_index: int,\n    spot_market_index: int,\n    max_pnl_transfer: int,\n    limit_price: int = None,\n    user_subaccount_id: int = 0,\n    liq_subaccount_id: int = 0,\n):\n    user_pk = get_user_account_public_key(\n        self.program_id, user_authority, user_subaccount_id\n    )\n    user_stats_pk = get_user_stats_account_public_key(\n        self.program_id,\n        user_authority,\n    )\n\n    liq_pk = self.get_user_account_public_key(liq_subaccount_id)\n    liq_stats_pk = self.get_user_stats_public_key()\n\n    remaining_accounts = await self.get_remaining_accounts(\n        writable_market_index=perp_market_index,\n        writable_spot_market_index=spot_market_index,\n        authority=[user_authority, self.authority],\n        user_id=[user_subaccount_id, liq_subaccount_id],\n    )\n\n    result = self.program.instruction[\"liquidate_perp_pnl_for_deposit\"](\n        perp_market_index,\n        spot_market_index,\n        max_pnl_transfer,\n        limit_price,\n        ctx=Context(\n            accounts={\n                \"state\": self.get_state_public_key(),\n                \"authority\": self.authority,\n                \"user\": user_pk,\n                \"user_stats\": user_stats_pk,\n                \"liquidator\": liq_pk,\n                \"liquidator_stats\": liq_stats_pk,\n            },\n            remaining_accounts=remaining_accounts,\n        ),\n    )\n    return result\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_liquidate_spot_ix","title":"<code>get_liquidate_spot_ix(user_authority, asset_market_index, liability_market_index, max_liability_transfer, limit_price=None, user_subaccount_id=0, liq_subaccount_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_liquidate_spot_ix(\n    self,\n    user_authority: PublicKey,\n    asset_market_index: int,\n    liability_market_index: int,\n    max_liability_transfer: int,\n    limit_price: int = None,\n    user_subaccount_id: int = 0,\n    liq_subaccount_id: int = 0,\n):\n    user_pk = get_user_account_public_key(\n        self.program_id, user_authority, user_id=user_subaccount_id\n    )\n    user_stats_pk = get_user_stats_account_public_key(\n        self.program_id,\n        user_authority,\n    )\n\n    liq_pk = self.get_user_account_public_key(liq_subaccount_id)\n    liq_stats_pk = self.get_user_stats_public_key()\n\n    remaining_accounts = await self.get_remaining_accounts(\n        writable_spot_market_index=[liability_market_index, asset_market_index],\n        authority=[user_authority, self.authority],\n        user_id=[user_subaccount_id, liq_subaccount_id],\n    )\n\n    return self.program.instruction[\"liquidate_spot\"](\n        asset_market_index,\n        liability_market_index,\n        max_liability_transfer,\n        limit_price,\n        ctx=Context(\n            accounts={\n                \"state\": self.get_state_public_key(),\n                \"authority\": self.authority,\n                \"user\": user_pk,\n                \"user_stats\": user_stats_pk,\n                \"liquidator\": liq_pk,\n                \"liquidator_stats\": liq_stats_pk,\n            },\n            remaining_accounts=remaining_accounts,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_open_position_ix","title":"<code>get_open_position_ix(direction, amount, market_index, user_id=0, limit_price=0, ioc=False)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_open_position_ix(\n    self,\n    direction: PositionDirection,\n    amount: int,\n    market_index: int,\n    user_id: int = 0,\n    limit_price: int = 0,\n    ioc: bool = False,\n):\n    order = self.default_order_params(\n        order_type=OrderType.MARKET(),\n        direction=direction,\n        market_index=market_index,\n        base_asset_amount=amount,\n    )\n    order.limit_price = limit_price\n\n    ix = await self.get_place_and_take_ix(order, subaccount_id=user_id)\n    return ix\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_place_and_take_ix","title":"<code>get_place_and_take_ix(order_params, maker_info=None, subaccount_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_place_and_take_ix(\n    self,\n    order_params: OrderParams,\n    maker_info: MakerInfo = None,\n    subaccount_id: int = 0,\n):\n    user_account_public_key = self.get_user_account_public_key(subaccount_id)\n\n    remaining_accounts = await self.get_remaining_accounts(\n        writable_market_index=order_params.market_index,\n        writable_spot_market_index=QUOTE_ASSET_BANK_INDEX,\n        user_id=subaccount_id,\n    )\n\n    maker_order_id = None\n    if maker_info is not None:\n        maker_order_id = maker_info.order.order_id\n        remaining_accounts.append(\n            AccountMeta(pubkey=maker_info.maker, is_signer=False, is_writable=True)\n        )\n\n    return self.program.instruction[\"place_and_take_perp_order\"](\n        order_params,\n        maker_order_id,\n        ctx=Context(\n            accounts={\n                \"state\": self.get_state_public_key(),\n                \"user\": user_account_public_key,\n                \"user_stats\": self.get_user_stats_public_key(),\n                \"authority\": self.authority,\n            },\n            remaining_accounts=remaining_accounts,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_place_perp_order_ix","title":"<code>get_place_perp_order_ix(order_params, user_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_place_perp_order_ix(\n    self,\n    order_params: OrderParams,\n    user_id: int = 0,\n):\n    user_account_public_key = self.get_user_account_public_key(user_id)\n    remaining_accounts = await self.get_remaining_accounts(\n        writable_market_index=order_params.market_index, user_id=user_id\n    )\n\n    ix = self.program.instruction[\"place_perp_order\"](\n        order_params,\n        ctx=Context(\n            accounts={\n                \"state\": self.get_state_public_key(),\n                \"user\": user_account_public_key,\n                \"authority\": self.signer.public_key,\n            },\n            remaining_accounts=remaining_accounts,\n        ),\n    )\n\n    return ix\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_place_perp_orders_ix","title":"<code>get_place_perp_orders_ix(order_params, user_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_place_perp_orders_ix(\n    self,\n    order_params: List[OrderParams],\n    user_id: int = 0,\n):\n    user_account_public_key = self.get_user_account_public_key(user_id)\n    writeable_market_indexes = list(set([x.market_index for x in order_params]))\n    remaining_accounts = await self.get_remaining_accounts(\n        writable_market_index=writeable_market_indexes, user_id=user_id\n    )\n\n    ixs = [\n        self.program.instruction[\"cancel_orders\"](\n            None,\n            None,\n            None,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": self.get_user_account_public_key(user_id),\n                    \"authority\": self.signer.public_key,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n    ]\n    for order_param in order_params:\n        ix = self.program.instruction[\"place_perp_order\"](\n            order_param,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": user_account_public_key,\n                    \"authority\": self.signer.public_key,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n        ixs.append(ix)\n\n    return ixs\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_place_spot_order_ix","title":"<code>get_place_spot_order_ix(order_params, user_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_place_spot_order_ix(\n    self,\n    order_params: OrderParams,\n    user_id: int = 0,\n):\n    user_account_public_key = self.get_user_account_public_key(user_id)\n\n    remaining_accounts = await self.get_remaining_accounts(\n        readable_spot_market_index=[0, order_params.market_index], user_id=user_id\n    )\n\n    ix = self.program.instruction[\"place_spot_order\"](\n        order_params,\n        ctx=Context(\n            accounts={\n                \"state\": self.get_state_public_key(),\n                \"user\": user_account_public_key,\n                \"authority\": self.signer.public_key,\n            },\n            remaining_accounts=remaining_accounts,\n        ),\n    )\n\n    return ix\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_place_spot_orders_ix","title":"<code>get_place_spot_orders_ix(order_params, user_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_place_spot_orders_ix(\n    self,\n    order_params: List[OrderParams],\n    user_id: int = 0,\n):\n    user_account_public_key = self.get_user_account_public_key(user_id)\n\n    remaining_accounts = await self.get_remaining_accounts(\n        writable_market_index=order_params[0].market_index, user_id=user_id\n    )\n\n    ixs = [\n        self.program.instruction[\"cancel_orders\"](\n            None,\n            None,\n            None,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": self.get_user_account_public_key(user_id),\n                    \"authority\": self.signer.public_key,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n    ]\n    for order_param in order_params:\n        ix = self.program.instruction[\"place_spot_order\"](\n            order_param,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"user\": user_account_public_key,\n                    \"authority\": self.signer.public_key,\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        )\n        ixs.append(ix)\n\n    return ixs\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_remaining_accounts","title":"<code>get_remaining_accounts(writable_market_index=None, writable_spot_market_index=None, readable_spot_market_index=None, user_id=[0], include_oracles=True, include_spot_markets=True, authority=None)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_remaining_accounts(\n    self,\n    writable_market_index: int = None,\n    writable_spot_market_index: int = None,\n    readable_spot_market_index: int = None,\n    user_id=[0],\n    include_oracles: bool = True,\n    include_spot_markets: bool = True,\n    authority: Optional[Union[PublicKey, Sequence[PublicKey]]] = None,\n):\n    if authority is None:\n        authority = [self.authority]\n    elif isinstance(authority, PublicKey):\n        authority = [authority]\n\n    if isinstance(user_id, int):\n        user_id = [user_id]\n    assert len(user_id) == len(authority) or len(user_id) == 0\n\n    accounts = []\n    for pk, id in zip(authority, user_id):\n        user_account = await get_user_account(self.program, pk, id)\n        accounts.append(user_account)\n\n    oracle_map = {}\n    spot_market_map = {}\n    market_map = {}\n\n    async def track_market(market_index, is_writable):\n        perp_market = await get_perp_market_account(self.program, market_index)\n        market_map[market_index] = AccountMeta(\n            pubkey=perp_market.pubkey,\n            is_signer=False,\n            is_writable=is_writable,\n        )\n\n        if include_oracles:\n            spot_market = await get_spot_market_account(\n                self.program, perp_market.quote_spot_market_index\n            )\n            if spot_market.oracle is not None:\n                oracle_map[str(spot_market.oracle)] = AccountMeta(\n                    pubkey=spot_market.oracle, is_signer=False, is_writable=False\n                )\n            oracle_map[str(perp_market.pubkey)] = AccountMeta(\n                pubkey=perp_market.amm.oracle, is_signer=False, is_writable=False\n            )\n\n    async def track_spot_market(spot_market_index, is_writable):\n        spot_market = await get_spot_market_account(self.program, spot_market_index)\n        spot_market_map[spot_market_index] = AccountMeta(\n            pubkey=spot_market.pubkey,\n            is_signer=False,\n            is_writable=is_writable,\n        )\n\n        if include_oracles:\n            oracle_map[str(spot_market.pubkey)] = AccountMeta(\n                pubkey=spot_market.oracle, is_signer=False, is_writable=False\n            )\n\n    for user_account in accounts:\n        for position in user_account.perp_positions:\n            if not is_available(position):\n                market_index = position.market_index\n                await track_market(market_index, is_writable=True)\n\n        if include_spot_markets:\n            for spot_market_balance in user_account.spot_positions:\n                if not is_spot_position_available(spot_market_balance):\n                    await track_spot_market(\n                        spot_market_balance.market_index, is_writable=False\n                    )\n\n            if readable_spot_market_index is not None:\n                if isinstance(readable_spot_market_index, int):\n                    readable_spot_market_index = [readable_spot_market_index]\n\n                for i in readable_spot_market_index:\n                    await track_spot_market(i, is_writable=False)\n\n    if writable_market_index is not None:\n        if isinstance(writable_market_index, int):\n            writable_market_index = [writable_market_index]\n\n        for i in writable_market_index:\n            await track_market(i, is_writable=True)\n\n    if writable_spot_market_index is not None and include_spot_markets:\n        if isinstance(writable_spot_market_index, int):\n            writable_spot_market_index = [writable_spot_market_index]\n\n        for i in writable_spot_market_index:\n            await track_spot_market(i, is_writable=True)\n\n    remaining_accounts = [\n        *oracle_map.values(),\n        *spot_market_map.values(),\n        *market_map.values(),\n    ]\n\n    return remaining_accounts\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_remove_insurance_fund_stake_ix","title":"<code>get_remove_insurance_fund_stake_ix(spot_market_index)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_remove_insurance_fund_stake_ix(self, spot_market_index: int):\n    ra = await self.get_remaining_accounts(\n        writable_spot_market_index=spot_market_index,\n        user_id=[],  # dont need the user account (might not exist)\n    )\n\n    return self.program.instruction[\"remove_insurance_fund_stake\"](\n        spot_market_index,\n        ctx=Context(\n            accounts={\n                \"state\": get_state_public_key(self.program_id),\n                \"spot_market\": get_spot_market_public_key(\n                    self.program_id, spot_market_index\n                ),\n                \"insurance_fund_stake\": get_insurance_fund_stake_public_key(\n                    self.program_id, self.authority, spot_market_index\n                ),\n                \"user_stats\": get_user_stats_account_public_key(\n                    self.program_id, self.authority\n                ),\n                \"authority\": self.authority,\n                \"insurance_fund_vault\": get_insurance_fund_vault_public_key(\n                    self.program_id, spot_market_index\n                ),\n                \"drift_signer\": get_clearing_house_signer_public_key(\n                    self.program_id\n                ),\n                \"user_token_account\": self.spot_market_atas[spot_market_index],\n                \"token_program\": TOKEN_PROGRAM_ID,\n            },\n            remaining_accounts=ra,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_remove_liquidity_ix","title":"<code>get_remove_liquidity_ix(amount, market_index, user_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_remove_liquidity_ix(\n    self, amount: int, market_index: int, user_id: int = 0\n):\n    remaining_accounts = await self.get_remaining_accounts(\n        writable_market_index=market_index, user_id=user_id\n    )\n    user_account_public_key = self.get_user_account_public_key(user_id)\n\n    return self.program.instruction[\"remove_perp_lp_shares\"](\n        amount,\n        market_index,\n        ctx=Context(\n            accounts={\n                \"state\": get_state_public_key(self.program_id),\n                \"user\": user_account_public_key,\n                \"authority\": self.authority,\n            },\n            remaining_accounts=remaining_accounts,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_request_remove_insurance_fund_stake_ix","title":"<code>get_request_remove_insurance_fund_stake_ix(spot_market_index, amount)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_request_remove_insurance_fund_stake_ix(\n    self,\n    spot_market_index: int,\n    amount: int,\n):\n    ra = await self.get_remaining_accounts(\n        writable_spot_market_index=spot_market_index,\n        user_id=[],  # dont need the user account (might not exist)\n    )\n\n    return self.program.instruction[\"request_remove_insurance_fund_stake\"](\n        spot_market_index,\n        amount,\n        ctx=Context(\n            accounts={\n                \"spot_market\": get_spot_market_public_key(\n                    self.program_id, spot_market_index\n                ),\n                \"insurance_fund_stake\": get_insurance_fund_stake_public_key(\n                    self.program_id, self.authority, spot_market_index\n                ),\n                \"user_stats\": get_user_stats_account_public_key(\n                    self.program_id, self.authority\n                ),\n                \"authority\": self.authority,\n                \"insurance_fund_vault\": get_insurance_fund_vault_public_key(\n                    self.program_id, spot_market_index\n                ),\n            },\n            remaining_accounts=ra,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_resolve_perp_bankruptcy_ix","title":"<code>get_resolve_perp_bankruptcy_ix(user_authority, market_index, user_subaccount_id=0, liq_subaccount_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_resolve_perp_bankruptcy_ix(\n    self,\n    user_authority: PublicKey,\n    market_index: int,\n    user_subaccount_id: int = 0,\n    liq_subaccount_id: int = 0,\n):\n    user_pk = get_user_account_public_key(\n        self.program_id, user_authority, user_subaccount_id\n    )\n    user_stats_pk = get_user_stats_account_public_key(\n        self.program_id,\n        user_authority,\n    )\n\n    liq_pk = self.get_user_account_public_key(liq_subaccount_id)\n    liq_stats_pk = self.get_user_stats_public_key()\n\n    remaining_accounts = await self.get_remaining_accounts(\n        writable_market_index=market_index,\n        writable_spot_market_index=QUOTE_ASSET_BANK_INDEX,\n        authority=[user_authority, self.authority],\n        user_id=[user_subaccount_id, liq_subaccount_id],\n    )\n\n    if_vault = get_insurance_fund_vault_public_key(self.program_id, market_index)\n    spot_vault = get_spot_market_vault_public_key(self.program_id, market_index)\n    ch_signer = get_clearing_house_signer_public_key(self.program_id)\n\n    return self.program.instruction[\"resolve_perp_bankruptcy\"](\n        QUOTE_ASSET_BANK_INDEX,\n        market_index,\n        ctx=Context(\n            accounts={\n                \"state\": self.get_state_public_key(),\n                \"authority\": self.authority,\n                \"user\": user_pk,\n                \"user_stats\": user_stats_pk,\n                \"liquidator\": liq_pk,\n                \"liquidator_stats\": liq_stats_pk,\n                \"spot_market_vault\": spot_vault,\n                \"insurance_fund_vault\": if_vault,\n                \"drift_signer\": ch_signer,\n                \"token_program\": TOKEN_PROGRAM_ID,\n            },\n            remaining_accounts=remaining_accounts,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_resolve_spot_bankruptcy_ix","title":"<code>get_resolve_spot_bankruptcy_ix(user_authority, spot_market_index, user_subaccount_id=0, liq_subaccount_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_resolve_spot_bankruptcy_ix(\n    self,\n    user_authority: PublicKey,\n    spot_market_index: int,\n    user_subaccount_id: int = 0,\n    liq_subaccount_id: int = 0,\n):\n    user_pk = get_user_account_public_key(\n        self.program_id, user_authority, user_subaccount_id\n    )\n    user_stats_pk = get_user_stats_account_public_key(\n        self.program_id,\n        user_authority,\n    )\n\n    liq_pk = self.get_user_account_public_key(liq_subaccount_id)\n    liq_stats_pk = self.get_user_stats_public_key()\n\n    remaining_accounts = await self.get_remaining_accounts(\n        writable_spot_market_index=spot_market_index,\n        authority=[user_authority, self.authority],\n        user_id=[user_subaccount_id, liq_subaccount_id],\n    )\n\n    if_vault = get_insurance_fund_vault_public_key(\n        self.program_id, spot_market_index\n    )\n    spot_vault = get_spot_market_vault_public_key(\n        self.program_id, spot_market_index\n    )\n    ch_signer = get_clearing_house_signer_public_key(self.program_id)\n\n    return self.program.instruction[\"resolve_spot_bankruptcy\"](\n        spot_market_index,\n        ctx=Context(\n            accounts={\n                \"state\": self.get_state_public_key(),\n                \"authority\": self.authority,\n                \"user\": user_pk,\n                \"user_stats\": user_stats_pk,\n                \"liquidator\": liq_pk,\n                \"liquidator_stats\": liq_stats_pk,\n                \"spot_market_vault\": spot_vault,\n                \"insurance_fund_vault\": if_vault,\n                \"drift_signer\": ch_signer,\n                \"token_program\": TOKEN_PROGRAM_ID,\n            },\n            remaining_accounts=remaining_accounts,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_settle_expired_market_ix","title":"<code>get_settle_expired_market_ix(market_index)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_settle_expired_market_ix(\n    self,\n    market_index: int,\n):\n    market = await get_perp_market_account(self.program, market_index)\n\n    market_account_infos = [\n        AccountMeta(\n            pubkey=market.pubkey,\n            is_writable=True,\n            is_signer=False,\n        )\n    ]\n\n    oracle_account_infos = [\n        AccountMeta(\n            pubkey=market.amm.oracle,\n            is_writable=False,\n            is_signer=False,\n        )\n    ]\n\n    spot_pk = get_spot_market_public_key(self.program_id, QUOTE_ASSET_BANK_INDEX)\n    spot_account_infos = [\n        AccountMeta(\n            pubkey=spot_pk,\n            is_writable=True,\n            is_signer=False,\n        )\n    ]\n\n    remaining_accounts = (\n        oracle_account_infos + spot_account_infos + market_account_infos\n    )\n\n    return self.program.instruction[\"settle_expired_market\"](\n        market_index,\n        ctx=Context(\n            accounts={\n                \"state\": self.get_state_public_key(),\n                \"authority\": self.authority,\n            },\n            remaining_accounts=remaining_accounts,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_settle_lp_ix","title":"<code>get_settle_lp_ix(settlee_authority, market_index, user_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_settle_lp_ix(\n    self, settlee_authority: PublicKey, market_index: int, user_id: int = 0\n):\n    remaining_accounts = await self.get_remaining_accounts(\n        writable_market_index=market_index,\n        authority=settlee_authority,\n        user_id=user_id,\n    )\n\n    return self.program.instruction[\"settle_lp\"](\n        market_index,\n        ctx=Context(\n            accounts={\n                \"state\": self.get_state_public_key(),\n                \"user\": get_user_account_public_key(\n                    self.program_id, settlee_authority, user_id\n                ),\n            },\n            remaining_accounts=remaining_accounts,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_settle_pnl_ix","title":"<code>get_settle_pnl_ix(user_authority, market_index, user_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_settle_pnl_ix(\n    self,\n    user_authority: PublicKey,\n    market_index: int,\n    user_id: int = 0,\n):\n    remaining_accounts = await self.get_remaining_accounts(\n        authority=user_authority,\n        writable_market_index=market_index,\n        writable_spot_market_index=QUOTE_ASSET_BANK_INDEX,\n        user_id=user_id,\n    )\n\n    return [\n        self.get_increase_compute_ix(),\n        self.program.instruction[\"settle_pnl\"](\n            market_index,\n            ctx=Context(\n                accounts={\n                    \"state\": self.get_state_public_key(),\n                    \"authority\": self.authority,\n                    \"user\": get_user_account_public_key(\n                        self.program_id, user_authority, user_id\n                    ),\n                    \"spot_market_vault\": get_spot_market_vault_public_key(\n                        self.program_id, QUOTE_ASSET_BANK_INDEX\n                    ),\n                },\n                remaining_accounts=remaining_accounts,\n            ),\n        ),\n    ]\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_state_public_key","title":"<code>get_state_public_key()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>def get_state_public_key(self):\n    return get_state_public_key(self.program_id)\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_update_amm_ix","title":"<code>get_update_amm_ix(market_indexs)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_update_amm_ix(\n    self,\n    market_indexs: list[int],\n):\n    n = len(market_indexs)\n    for _ in range(5 - n):\n        market_indexs.append(100)\n\n    market_infos = []\n    oracle_infos = []\n    for idx in market_indexs:\n        if idx != 100:\n            market = await get_perp_market_account(self.program, idx)\n            market_infos.append(\n                AccountMeta(\n                    pubkey=market.pubkey,\n                    is_signer=False,\n                    is_writable=True,\n                )\n            )\n            oracle_infos.append(\n                AccountMeta(\n                    pubkey=market.amm.oracle, is_signer=False, is_writable=False\n                )\n            )\n\n    remaining_accounts = oracle_infos + market_infos\n\n    return self.program.instruction[\"update_amms\"](\n        market_indexs,\n        ctx=Context(\n            accounts={\n                \"state\": self.get_state_public_key(),\n                \"authority\": self.authority,\n            },\n            remaining_accounts=remaining_accounts,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_user","title":"<code>get_user(user_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_user(self, user_id=0) -&gt; User:\n    return await get_user_account(self.program, self.authority, user_id)\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_user_account_public_key","title":"<code>get_user_account_public_key(user_id=0)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>def get_user_account_public_key(self, user_id=0) -&gt; PublicKey:\n    return get_user_account_public_key(self.program_id, self.authority, user_id)\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_user_position","title":"<code>get_user_position(market_index, subaccount_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_user_position(\n    self,\n    market_index: int,\n    subaccount_id: int = 0,\n) -&gt; Optional[PerpPosition]:\n    user = await get_user_account(self.program, self.authority, subaccount_id)\n\n    found = False\n    for position in user.perp_positions:\n        if position.market_index == market_index and not is_available(position):\n            found = True\n            break\n\n    if not found:\n        return None\n\n    return position\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_user_spot_position","title":"<code>get_user_spot_position(market_index, user_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_user_spot_position(\n    self,\n    market_index: int,\n    user_id: int = 0,\n) -&gt; Optional[SpotPosition]:\n    user = await get_user_account(self.program, self.authority, user_id)\n\n    found = False\n    for position in user.spot_positions:\n        if (\n            position.market_index == market_index\n            and not is_spot_position_available(position)\n        ):\n            found = True\n            break\n\n    if not found:\n        return None\n\n    return position\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_user_stats_public_key","title":"<code>get_user_stats_public_key()</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>def get_user_stats_public_key(self):\n    return get_user_stats_account_public_key(self.program_id, self.authority)\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.get_withdraw_collateral_ix","title":"<code>get_withdraw_collateral_ix(amount, spot_market_index, user_token_account, reduce_only=False, user_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def get_withdraw_collateral_ix(\n    self,\n    amount: int,\n    spot_market_index: int,\n    user_token_account: PublicKey,\n    reduce_only: bool = False,\n    user_id: int = 0,\n):\n    spot_market = await get_spot_market_account(self.program, spot_market_index)\n    remaining_accounts = await self.get_remaining_accounts(\n        writable_spot_market_index=spot_market_index,\n        readable_spot_market_index=QUOTE_ASSET_BANK_INDEX,\n        user_id=user_id,\n    )\n    ch_signer = get_clearing_house_signer_public_key(self.program_id)\n\n    return self.program.instruction[\"withdraw\"](\n        spot_market_index,\n        amount,\n        reduce_only,\n        ctx=Context(\n            accounts={\n                \"state\": self.get_state_public_key(),\n                \"spot_market\": spot_market.pubkey,\n                \"spot_market_vault\": spot_market.vault,\n                \"drift_signer\": ch_signer,\n                \"user\": self.get_user_account_public_key(user_id),\n                \"user_stats\": self.get_user_stats_public_key(),\n                \"user_token_account\": user_token_account,\n                \"authority\": self.authority,\n                \"token_program\": TOKEN_PROGRAM_ID,\n            },\n            remaining_accounts=remaining_accounts,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.initialize_insurance_fund_stake","title":"<code>initialize_insurance_fund_stake(spot_market_index)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def initialize_insurance_fund_stake(\n    self,\n    spot_market_index: int,\n):\n    return await self.send_ixs(\n        self.get_initialize_insurance_fund_stake_ix(spot_market_index)\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.intialize_user","title":"<code>intialize_user(user_id=0)</code>  <code>async</code>","text":"<p>intializes a drift user</p> <p>Parameters:</p> Name Type Description Default <code>user_id</code> <code>int</code> <p>subaccount id to initialize. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>str</code> <p>tx signature</p> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def intialize_user(self, user_id: int = 0):\n\"\"\"intializes a drift user\n\n    Args:\n        user_id (int, optional): subaccount id to initialize. Defaults to 0.\n\n    Returns:\n        str: tx signature\n    \"\"\"\n    ixs = []\n    if user_id == 0:\n        ixs.append(self.get_initialize_user_stats())\n    ix = self.get_initialize_user_instructions(user_id)\n    ixs.append(ix)\n    return await self.send_ixs(ixs)\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.liquidate_perp","title":"<code>liquidate_perp(user_authority, market_index, max_base_asset_amount, limit_price=None, user_subaccount_id=0, liq_subaccount_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def liquidate_perp(\n    self,\n    user_authority: PublicKey,\n    market_index: int,\n    max_base_asset_amount: int,\n    limit_price: Optional[int] = None,\n    user_subaccount_id: int = 0,\n    liq_subaccount_id: int = 0,\n):\n    return await self.send_ixs(\n        [\n            await self.get_liquidate_perp_ix(\n                user_authority,\n                market_index,\n                max_base_asset_amount,\n                limit_price,\n                user_subaccount_id,\n                liq_subaccount_id,\n            )\n        ]\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.liquidate_perp_pnl_for_deposit","title":"<code>liquidate_perp_pnl_for_deposit(user_authority, perp_market_index, spot_market_index, max_pnl_transfer, user_subaccount_id=0, liq_subaccount_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def liquidate_perp_pnl_for_deposit(\n    self,\n    user_authority: PublicKey,\n    perp_market_index: int,\n    spot_market_index: int,\n    max_pnl_transfer: int,\n    user_subaccount_id: int = 0,\n    liq_subaccount_id: int = 0,\n):\n    return await self.send_ixs(\n        self.get_liquidate_perp_pnl_for_deposit_ix(\n            user_authority,\n            perp_market_index,\n            spot_market_index,\n            max_pnl_transfer,\n            user_subaccount_id,\n            liq_subaccount_id,\n        )\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.liquidate_spot","title":"<code>liquidate_spot(user_authority, asset_market_index, liability_market_index, max_liability_transfer, user_subaccount_id=0, liq_subaccount_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def liquidate_spot(\n    self,\n    user_authority: PublicKey,\n    asset_market_index: int,\n    liability_market_index: int,\n    max_liability_transfer: int,\n    user_subaccount_id: int = 0,\n    liq_subaccount_id: int = 0,\n):\n    return await self.send_ixs(\n        [\n            await self.get_liquidate_spot_ix(\n                user_authority,\n                asset_market_index,\n                liability_market_index,\n                max_liability_transfer,\n                user_subaccount_id,\n                liq_subaccount_id,\n            )\n        ]\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.open_position","title":"<code>open_position(direction, amount, market_index, user_id=0, limit_price=0, ioc=False)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def open_position(\n    self,\n    direction: PositionDirection,\n    amount: int,\n    market_index: int,\n    user_id: int = 0,\n    limit_price: int = 0,\n    ioc: bool = False,\n):\n    return await self.send_ixs(\n        await self.get_open_position_ix(\n            direction,\n            amount,\n            market_index,\n            user_id,\n            limit_price,\n            ioc,\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.place_and_take","title":"<code>place_and_take(order_params, maker_info=None, subaccount_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def place_and_take(\n    self,\n    order_params: OrderParams,\n    maker_info: MakerInfo = None,\n    subaccount_id: int = 0,\n):\n    return await self.send_ixs(\n        [\n            self.get_increase_compute_ix(),\n            await self.get_place_and_take_ix(\n                order_params, maker_info, subaccount_id\n            ),\n        ]\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.place_perp_order","title":"<code>place_perp_order(order_params, maker_info=None, user_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def place_perp_order(\n    self,\n    order_params: OrderParams,\n    maker_info: MakerInfo = None,\n    user_id: int = 0,\n):\n    return await self.send_ixs(\n        [\n            self.get_increase_compute_ix(),\n            await self.get_place_perp_order_ix(order_params, maker_info, user_id),\n        ]\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.place_spot_order","title":"<code>place_spot_order(order_params, maker_info=None, user_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def place_spot_order(\n    self,\n    order_params: OrderParams,\n    maker_info: MakerInfo = None,\n    user_id: int = 0,\n):\n    return await self.send_ixs(\n        [\n            self.get_increase_compute_ix(),\n            await self.get_place_spot_order_ix(order_params, maker_info, user_id),\n        ]\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.remove_insurance_fund_stake","title":"<code>remove_insurance_fund_stake(spot_market_index)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def remove_insurance_fund_stake(self, spot_market_index: int):\n    return await self.send_ixs(\n        await self.get_remove_insurance_fund_stake_ix(spot_market_index)\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.remove_liquidity","title":"<code>remove_liquidity(amount, market_index, user_id=0)</code>  <code>async</code>","text":"<p>burns LP tokens and removes liquidity to the DAMM</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>amount of lp tokens to burn</p> required <code>market_index</code> <code>int</code> required <code>user_id</code> <code>int</code> <p>subaccount id. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>str</code> <p>tx sig</p> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def remove_liquidity(self, amount: int, market_index: int, user_id: int = 0):\n\"\"\"burns LP tokens and removes liquidity to the DAMM\n\n    Args:\n        amount (int): amount of lp tokens to burn\n        market_index (int):\n        user_id (int, optional): subaccount id. Defaults to 0.\n\n    Returns:\n        str: tx sig\n    \"\"\"\n    return await self.send_ixs(\n        [await self.get_remove_liquidity_ix(amount, market_index, user_id)]\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.request_remove_insurance_fund_stake","title":"<code>request_remove_insurance_fund_stake(spot_market_index, amount)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def request_remove_insurance_fund_stake(\n    self, spot_market_index: int, amount: int\n):\n    return await self.send_ixs(\n        await self.get_request_remove_insurance_fund_stake_ix(\n            spot_market_index, amount\n        )\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.resolve_perp_bankruptcy","title":"<code>resolve_perp_bankruptcy(user_authority, market_index, user_subaccount_id=0, liq_subaccount_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def resolve_perp_bankruptcy(\n    self,\n    user_authority: PublicKey,\n    market_index: int,\n    user_subaccount_id: int = 0,\n    liq_subaccount_id: int = 0,\n):\n    return await self.send_ixs(\n        [\n            await self.get_resolve_perp_bankruptcy_ix(\n                user_authority,\n                market_index,\n                user_subaccount_id,\n                liq_subaccount_id,\n            )\n        ]\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.resolve_spot_bankruptcy","title":"<code>resolve_spot_bankruptcy(user_authority, spot_market_index, user_subaccount_id=0, liq_subaccount_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def resolve_spot_bankruptcy(\n    self,\n    user_authority: PublicKey,\n    spot_market_index: int,\n    user_subaccount_id: int = 0,\n    liq_subaccount_id: int = 0,\n):\n    return await self.send_ixs(\n        [\n            await self.get_resolve_spot_bankruptcy_ix(\n                user_authority,\n                spot_market_index,\n                user_subaccount_id,\n                liq_subaccount_id,\n            )\n        ]\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.send_ixs","title":"<code>send_ixs(ixs, signers=None)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def send_ixs(\n    self,\n    ixs: Union[TransactionInstruction, list[TransactionInstruction]],\n    signers=None,\n):\n    if isinstance(ixs, TransactionInstruction):\n        ixs = [ixs]\n\n    tx = Transaction()\n    for ix in ixs:\n        tx.add(ix)\n\n    if signers is None:\n        signers = self.signers\n\n    return await self.program.provider.send(tx, signers=signers)\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.settle_expired_market","title":"<code>settle_expired_market(market_index)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def settle_expired_market(\n    self,\n    market_index: int,\n):\n    return await self.send_ixs(\n        [\n            self.get_increase_compute_ix(),\n            await self.get_settle_expired_market_ix(\n                market_index,\n            ),\n        ]\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.settle_lp","title":"<code>settle_lp(settlee_authority, market_index, user_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def settle_lp(\n    self,\n    settlee_authority: PublicKey,\n    market_index: int,\n    user_id: int = 0,\n):\n    return await self.send_ixs(\n        [await self.get_settle_lp_ix(settlee_authority, market_index, user_id)],\n        signers=[],\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.settle_pnl","title":"<code>settle_pnl(user_authority, market_index, user_id=0)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def settle_pnl(\n    self,\n    user_authority: PublicKey,\n    market_index: int,\n    user_id: int = 0,\n):\n    return await self.send_ixs(\n        await self.get_settle_pnl_ix(user_authority, market_index, user_id)\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.settle_revenue_to_insurance_fund","title":"<code>settle_revenue_to_insurance_fund(spot_market_index)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def settle_revenue_to_insurance_fund(self, spot_market_index: int):\n    return await self.program.rpc[\"settle_revenue_to_insurance_fund\"](\n        spot_market_index,\n        ctx=Context(\n            accounts={\n                \"state\": get_state_public_key(self.program_id),\n                \"spot_market\": get_spot_market_public_key(\n                    self.program_id, spot_market_index\n                ),\n                \"spot_market_vault\": get_spot_market_vault_public_key(\n                    self.program_id, spot_market_index\n                ),\n                \"drift_signer\": get_clearing_house_signer_public_key(\n                    self.program_id\n                ),\n                \"insurance_fund_vault\": get_insurance_fund_vault_public_key(\n                    self.program_id,\n                    spot_market_index,\n                ),\n                \"token_program\": TOKEN_PROGRAM_ID,\n            }\n        ),\n    )\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.update_amm","title":"<code>update_amm(market_indexs)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def update_amm(self, market_indexs: list[int]):\n    return await self.send_ixs(await self.get_update_amm_ix(market_indexs))\n</code></pre>"},{"location":"clearing_house/#driftpy.clearing_house.ClearingHouse.withdraw","title":"<code>withdraw(amount, spot_market_index, user_token_account, reduce_only=False, user_id=0)</code>  <code>async</code>","text":"<p>withdraws from drift protocol (can also allow borrowing)</p> <p>Parameters:</p> Name Type Description Default <code>amount</code> <code>int</code> <p>amount to withdraw</p> required <code>spot_market_index</code> <code>int</code> required <code>user_token_account</code> <code>PublicKey</code> <p>ata of the account to withdraw to</p> required <code>reduce_only</code> <code>bool</code> <p>if True will only withdraw existing funds else if False will allow taking out borrows. Defaults to False.</p> <code>False</code> <code>user_id</code> <code>int</code> <p>subaccount. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Name Type Description <code>str</code> <p>tx sig</p> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house.py</code> <pre><code>async def withdraw(\n    self,\n    amount: int,\n    spot_market_index: int,\n    user_token_account: PublicKey,\n    reduce_only: bool = False,\n    user_id: int = 0,\n):\n\"\"\"withdraws from drift protocol (can also allow borrowing)\n\n    Args:\n        amount (int): amount to withdraw\n        spot_market_index (int):\n        user_token_account (PublicKey): ata of the account to withdraw to\n        reduce_only (bool, optional): if True will only withdraw existing funds else if False will allow taking out borrows. Defaults to False.\n        user_id (int, optional): subaccount. Defaults to 0.\n\n    Returns:\n        str: tx sig\n    \"\"\"\n    return await self.send_ixs(\n        [\n            await self.get_withdraw_collateral_ix(\n                amount, spot_market_index, user_token_account, reduce_only, user_id\n            )\n        ]\n    )\n</code></pre>"},{"location":"clearing_house_user/","title":"Clearing House User","text":"<p>This object is used to fetch data from the protocol and view user metrics (leverage, free collateral, etc.)</p>"},{"location":"clearing_house_user/#example","title":"Example","text":"<pre><code>clearing_house = ClearingHouse.from_config(config, provider)\nclearing_house_user = ClearingHouseUser(clearing_house)\n\n# inspect user's leverage \nleverage = await clearing_house_user.get_leverage()\nprint('current leverage:', leverage / 10_000)\n\n# you can also inspect other accounts information using the (authority=) flag\nbigz_chu = ClearingHouseUser(clearing_house, authority=PublicKey('bigZ'))\nleverage = await bigz_chu.get_leverage()\nprint('bigZs leverage:', leverage / 10_000)\n\n# clearing house user calls can be expensive on the rpc so we can cache them \nclearing_house_user = ClearingHouseUser(clearing_house, use_cache=True)\nawait clearing_house_user.set_cache()\n\n# works without any rpc calls (uses the cached data)\nupnl = await chu.get_unrealized_pnl(with_funding=True)\nprint('upnl:', upnl)\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user","title":"<code>clearing_house_user</code>","text":""},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser","title":"<code>ClearingHouseUser</code>","text":"<p>This class is the main way to retrieve and inspect data on Drift Protocol.</p> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>class ClearingHouseUser:\n\"\"\"This class is the main way to retrieve and inspect data on Drift Protocol.\"\"\"\n\n    def __init__(\n        self,\n        clearing_house: ClearingHouse,\n        authority: Optional[PublicKey] = None,\n        subaccount_id: int = 0,\n        use_cache: bool = False,\n    ):\n\"\"\"Initialize the clearing house user object\n\n        Args:\n            clearing_house (ClearingHouse): required for program_id, idl, things (keypair doesnt matter)\n            authority (Optional[PublicKey], optional): authority to investigate if None will use clearing_house.authority\n            subaccount_id (int, optional): subaccount of authority to investigate. Defaults to 0.\n            use_cache (bool, optional): sdk uses a lot of rpc calls rn - use this flag and .set_cache() to cache accounts and reduce rpc calls. Defaults to False.\n        \"\"\"\n        self.clearing_house = clearing_house\n        self.authority = authority\n        if self.authority is None:\n            self.authority = clearing_house.authority\n\n        self.program = clearing_house.program\n        self.oracle_program = clearing_house\n        self.connection = self.program.provider.connection\n        self.subaccount_id = subaccount_id\n        self.use_cache = use_cache\n        self.cache_is_set = False\n\n    # cache all state, perpmarket, oracle, etc. in single cache -- user calls reload\n    # when they want to update the data?\n    # get_spot_market\n    # get_perp_market\n    # get_user\n    # if state = cache =&gt; get cached_market else get new market\n    async def set_cache_last(self, CACHE=None):\n\"\"\"sets the cache of the accounts to use to inspect\n\n        Args:\n            CACHE (dict, optional): other existing cache object - if None will pull \u0192resh accounts from RPC. Defaults to None.\n        \"\"\"\n        self.cache_is_set = True\n\n        if CACHE is not None:\n            self.CACHE = CACHE\n            return\n\n        self.CACHE = {}\n        state = await get_state_account(self.program)\n        self.CACHE[\"state\"] = state\n\n        spot_markets = []\n        spot_market_oracle_data = []\n        for i in range(state.number_of_spot_markets):\n            spot_market = await get_spot_market_account(self.program, i)\n            spot_markets.append(spot_market)\n\n            if i == 0:\n                spot_market_oracle_data.append(\n                    OracleData(PRICE_PRECISION, 0, 1, 1, 0, True)\n                )\n            else:\n                oracle_data = OracleData(\n                    spot_market.historical_oracle_data.last_oracle_price,\n                    0,\n                    1,\n                    1,\n                    0,\n                    True,\n                )\n                spot_market_oracle_data.append(oracle_data)\n\n        self.CACHE[\"spot_markets\"] = spot_markets\n        self.CACHE[\"spot_market_oracles\"] = spot_market_oracle_data\n\n        perp_markets = []\n        perp_market_oracle_data = []\n        for i in range(state.number_of_markets):\n            perp_market = await get_perp_market_account(self.program, i)\n            perp_markets.append(perp_market)\n\n            oracle_data = OracleData(\n                perp_market.amm.historical_oracle_data.last_oracle_price,\n                0,\n                1,\n                1,\n                0,\n                True,\n            )\n            perp_market_oracle_data.append(oracle_data)\n\n        self.CACHE[\"perp_markets\"] = perp_markets\n        self.CACHE[\"perp_market_oracles\"] = perp_market_oracle_data\n\n        user = await get_user_account(self.program, self.authority, self.subaccount_id)\n        self.CACHE[\"user\"] = user\n\n    async def set_cache(self, CACHE=None):\n\"\"\"sets the cache of the accounts to use to inspect\n\n        Args:\n            CACHE (dict, optional): other existing cache object - if None will pull \u0192resh accounts from RPC. Defaults to None.\n        \"\"\"\n        self.cache_is_set = True\n\n        if CACHE is not None:\n            self.CACHE = CACHE\n            return\n\n        self.CACHE = {}\n        state = await get_state_account(self.program)\n        self.CACHE[\"state\"] = state\n\n        spot_markets = []\n        spot_market_oracle_data = []\n        for i in range(state.number_of_spot_markets):\n            spot_market = await get_spot_market_account(self.program, i)\n            spot_markets.append(spot_market)\n\n            if i == 0:\n                spot_market_oracle_data.append(\n                    OracleData(PRICE_PRECISION, 0, 1, 1, 0, True)\n                )\n            else:\n                oracle_data = await get_oracle_data(self.connection, spot_market.oracle,  spot_market.oracle_source)\n                spot_market_oracle_data.append(oracle_data)\n\n        self.CACHE[\"spot_markets\"] = spot_markets\n        self.CACHE[\"spot_market_oracles\"] = spot_market_oracle_data\n\n        perp_markets = []\n        perp_market_oracle_data = []\n        for i in range(state.number_of_markets):\n            perp_market = await get_perp_market_account(self.program, i)\n            perp_markets.append(perp_market)\n\n            oracle_data = await get_oracle_data(self.connection, perp_market.amm.oracle, perp_market.amm.oracle_source)\n            perp_market_oracle_data.append(oracle_data)\n\n        self.CACHE[\"perp_markets\"] = perp_markets\n        self.CACHE[\"perp_market_oracles\"] = perp_market_oracle_data\n\n        user = await get_user_account(self.program, self.authority, self.subaccount_id)\n        self.CACHE[\"user\"] = user\n\n    async def get_spot_oracle_data(self, spot_market: SpotMarket):\n        if self.use_cache:\n            assert self.cache_is_set, \"must call clearing_house_user.set_cache() first\"\n            return self.CACHE[\"spot_market_oracles\"][spot_market.market_index]\n        else:\n            oracle_data = await get_oracle_data(self.connection, spot_market.oracle, spot_market.oracle_source)\n            return oracle_data\n\n    async def get_perp_oracle_data(self, perp_market: PerpMarket):\n        if self.use_cache:\n            assert self.cache_is_set, \"must call clearing_house_user.set_cache() first\"\n            return self.CACHE[\"perp_market_oracles\"][perp_market.market_index]\n        else:\n            oracle_data = await get_oracle_data(self.connection, perp_market.amm.oracle,  perp_market.amm.oracle_source)\n            return oracle_data\n\n    async def get_state(self):\n        if self.use_cache:\n            assert self.cache_is_set, \"must call clearing_house_user.set_cache() first\"\n            return self.CACHE[\"state\"]\n        else:\n            return await get_state_account(self.program)\n\n    async def get_spot_market(self, i):\n        if self.use_cache:\n            assert self.cache_is_set, \"must call clearing_house_user.set_cache() first\"\n            return self.CACHE[\"spot_markets\"][i]\n        else:\n            return await get_spot_market_account(self.program, i)\n\n    async def get_perp_market(self, i):\n        if self.use_cache:\n            assert self.cache_is_set, \"must call clearing_house_user.set_cache() first\"\n            return self.CACHE[\"perp_markets\"][i]\n        else:\n            return await get_perp_market_account(self.program, i)\n\n    async def get_user(self):\n        if self.use_cache:\n            assert self.cache_is_set, \"must call clearing_house_user.set_cache() first\"\n            return self.CACHE[\"user\"]\n        else:\n            return await get_user_account(\n                self.program, self.authority, self.subaccount_id\n            )\n\n    async def get_spot_market_liability(\n        self,\n        market_index=None,\n        margin_category=None,\n        liquidation_buffer=None,\n        include_open_orders=None,\n    ):\n        user = await self.get_user()\n        total_liability = 0\n        for position in user.spot_positions:\n            if is_spot_position_available(position) or (\n                market_index is not None and position.market_index != market_index\n            ):\n                continue\n\n            spot_market = await self.get_spot_market(position.market_index)\n\n            if position.market_index == QUOTE_ASSET_BANK_INDEX:\n                if str(position.balance_type) == \"SpotBalanceType.Borrow()\":\n                    token_amount = get_token_amount(\n                        position.scaled_balance, spot_market, position.balance_type\n                    )\n                    weight = SPOT_WEIGHT_PRECISION\n                    if margin_category == MarginCategory.INITIAL:\n                        weight = max(weight, user.max_margin_ratio)\n\n                    value = token_amount * weight / SPOT_WEIGHT_PRECISION\n                    total_liability += value\n                    continue\n                else:\n                    continue\n\n            oracle_data = await self.get_spot_oracle_data(spot_market)\n            if not include_open_orders:\n                if str(position.balance_type) == \"SpotBalanceType.Borrow()\":\n                    token_amount = get_token_amount(\n                        position.scaled_balance, spot_market, position.balance_type\n                    )\n                    liability_value = get_spot_liability_value(\n                        token_amount,\n                        oracle_data,\n                        spot_market,\n                        margin_category,\n                        liquidation_buffer,\n                        user.max_margin_ratio,\n                    )\n                    total_liability += liability_value\n                    continue\n                else:\n                    continue\n\n            (\n                worst_case_token_amount,\n                worst_case_quote_amount,\n            ) = get_worst_case_token_amounts(position, spot_market, oracle_data)\n\n            if worst_case_token_amount &lt; 0:\n                baa_value = get_spot_liability_value(\n                    abs(worst_case_token_amount),\n                    oracle_data,\n                    spot_market,\n                    margin_category,\n                    liquidation_buffer,\n                    user.max_margin_ratio,\n                )\n                total_liability += baa_value\n\n            if worst_case_quote_amount &lt; 0:\n                weight = SPOT_WEIGHT_PRECISION\n                if margin_category == MarginCategory.INITIAL:\n                    weight = max(weight, user.max_margin_ratio)\n                weighted_value = (\n                    abs(worst_case_quote_amount) * weight / SPOT_WEIGHT_PRECISION\n                )\n                total_liability += weighted_value\n\n        return total_liability\n\n    async def get_total_perp_liability(\n        self,\n        margin_category: Optional[MarginCategory] = None,\n        liquidation_buffer: Optional[int] = 0,\n        include_open_orders: bool = False,\n    ):\n        user = await self.get_user()\n\n        unrealized_pnl = 0\n        for position in user.perp_positions:\n            market = await self.get_perp_market(position.market_index)\n\n            if position.lp_shares &gt; 0:\n                pass\n\n            price = (await self.get_perp_oracle_data(market)).price\n            base_asset_amount = (\n                calculate_worst_case_base_asset_amount(position)\n                if include_open_orders\n                else position.base_asset_amount\n            )\n            base_value = (\n                abs(base_asset_amount)\n                * price\n                / (AMM_TO_QUOTE_PRECISION_RATIO * PRICE_PRECISION)\n            )\n\n            if margin_category is not None:\n                margin_ratio = calculate_market_margin_ratio(\n                    market, abs(base_asset_amount), margin_category\n                )\n\n                if margin_category == MarginCategory.INITIAL:\n                    margin_ratio = max(margin_ratio, user.max_margin_ratio)\n\n                if liquidation_buffer is not None:\n                    margin_ratio += liquidation_buffer\n\n                base_value = base_value * margin_ratio / MARGIN_PRECISION\n\n            unrealized_pnl += base_value\n        return unrealized_pnl\n\n    async def can_be_liquidated(self) -&gt; bool:\n        total_collateral = await self.get_total_collateral()\n\n        user = await self.get_user()\n        liquidation_buffer = None\n        if user.being_liquidated:\n            liquidation_buffer = (\n                await self.get_state()\n            ).liquidation_margin_buffer_ratio\n\n        maintenance_req = await self.get_margin_requirement(\n            MarginCategory.MAINTENANCE, liquidation_buffer\n        )\n\n        return total_collateral &lt; maintenance_req\n\n    async def get_margin_requirement(\n        self,\n        margin_category: MarginCategory,\n        liquidation_buffer: Optional[int] = 0,\n        include_open_orders=True,\n        include_spot=True,\n    ) -&gt; int:\n        perp_liability = await self.get_total_perp_liability(\n            margin_category, liquidation_buffer, include_open_orders\n        )\n\n        result = perp_liability\n        if include_spot:\n            spot_liability = await self.get_spot_market_liability(\n                None, margin_category, liquidation_buffer, include_open_orders\n            )\n            result += spot_liability\n\n        return result\n\n    async def get_total_collateral(\n        self, margin_category: Optional[MarginCategory] = None\n    ) -&gt; int:\n        spot_collateral = await self.get_spot_market_asset_value(\n            margin_category,\n            include_open_orders=True,\n        )\n        pnl = await self.get_unrealized_pnl(\n            True, with_weight_margin_category=margin_category\n        )\n        total_collateral = spot_collateral + pnl\n        return total_collateral\n\n    async def get_free_collateral(self):\n        total_collateral = await self.get_total_collateral()\n        init_margin_req = await self.get_margin_requirement(\n            MarginCategory.INITIAL,\n        )\n        free_collateral = total_collateral - init_margin_req\n        free_collateral = max(0, free_collateral)\n        return free_collateral\n\n    async def get_user_spot_position(\n        self,\n        market_index: int,\n    ) -&gt; Optional[SpotPosition]:\n        user = await self.get_user()\n\n        found = False\n        for position in user.spot_positions:\n            if (\n                position.market_index == market_index\n                and not is_spot_position_available(position)\n            ):\n                found = True\n                break\n\n        if not found:\n            return None\n\n        return position\n\n    async def get_user_position(\n        self,\n        market_index: int,\n    ) -&gt; Optional[PerpPosition]:\n        user = await self.get_user()\n\n        found = False\n        for position in user.perp_positions:\n            if position.market_index == market_index and not is_available(position):\n                found = True\n                break\n\n        if not found:\n            return None\n\n        return position\n\n    async def get_unrealized_pnl(\n        self,\n        with_funding: bool = False,\n        market_index: int = None,\n        with_weight_margin_category: Optional[MarginCategory] = None,\n    ):\n        user = await self.get_user()\n        quote_spot_market = await self.get_spot_market(QUOTE_ASSET_BANK_INDEX)\n\n        unrealized_pnl = 0\n        position: PerpPosition\n        for position in user.perp_positions:\n            if market_index is not None and position.market_index != market_index:\n                continue\n\n            market = await self.get_perp_market(position.market_index)\n\n            oracle_data = await self.get_perp_oracle_data(market)\n            position_unrealized_pnl = calculate_position_pnl_with_oracle(\n                market, position, oracle_data, with_funding\n            )\n\n            if with_weight_margin_category is not None:\n                if position_unrealized_pnl &gt; 0:\n                    unrealized_asset_weight = calculate_unrealized_asset_weight(\n                        market,\n                        quote_spot_market,\n                        position_unrealized_pnl,\n                        with_weight_margin_category,\n                        oracle_data,\n                    )\n                    position_unrealized_pnl = (\n                        position_unrealized_pnl\n                        * unrealized_asset_weight\n                        / SPOT_WEIGHT_PRECISION\n                    )\n\n            unrealized_pnl += position_unrealized_pnl\n\n        return unrealized_pnl\n\n    async def get_spot_market_asset_value(\n        self,\n        margin_category: Optional[MarginCategory] = None,\n        include_open_orders=True,\n        market_index: Optional[int] = None,\n    ):\n        user = await self.get_user()\n        total_value = 0\n        for position in user.spot_positions:\n            if is_spot_position_available(position) or (\n                market_index is not None and position.market_index != market_index\n            ):\n                continue\n\n            spot_market = await self.get_spot_market(position.market_index)\n\n            if position.market_index == QUOTE_ASSET_BANK_INDEX:\n                spot_token_value = get_token_amount(\n                    position.scaled_balance, spot_market, position.balance_type\n                )\n\n                match str(position.balance_type):\n                    case \"SpotBalanceType.Deposit()\":\n                        spot_token_value *= 1\n                    case \"SpotBalanceType.Borrow()\":\n                        spot_token_value *= -1\n                    case _:\n                        raise Exception(\n                            f\"Invalid balance type: {position.balance_type}\"\n                        )\n\n                total_value += spot_token_value\n                continue\n\n            oracle_data = await self.get_spot_oracle_data(spot_market)\n\n            if not include_open_orders:\n                token_amount = get_token_amount(\n                        position.scaled_balance, spot_market, position.balance_type\n                    )\n                spot_token_value = get_spot_asset_value(\n                        token_amount, oracle_data, spot_market, margin_category\n                    )           \n                match str(position.balance_type):\n                    case \"SpotBalanceType.Deposit()\":\n                        spot_token_value *= 1\n                    case \"SpotBalanceType.Borrow()\":\n                        spot_token_value *= -1\n                    case _:\n                        raise Exception(\n                            f\"Invalid balance type: {position.balance_type}\"\n                        )\n                total_value += spot_token_value\n                continue\n\n            (\n                worst_case_token_amount,\n                worst_case_quote_amount,\n            ) = get_worst_case_token_amounts(position, spot_market, oracle_data)\n\n            if worst_case_token_amount &gt; 0:\n                baa_value = get_spot_asset_value(\n                    worst_case_token_amount, oracle_data, spot_market, margin_category\n                )\n                total_value += baa_value\n\n            if worst_case_quote_amount &gt; 0:\n                total_value += worst_case_quote_amount\n\n        return total_value\n\n    async def get_leverage(\n        self, margin_category: Optional[MarginCategory] = None\n    ) -&gt; int:\n        total_liability = await self.get_margin_requirement(margin_category, None)\n        total_asset_value = await self.get_total_collateral(margin_category)\n\n        if total_asset_value == 0 or total_liability == 0:\n            return 0\n\n        leverage = total_liability * 10_000 / total_asset_value\n\n        return leverage\n\n    async def get_perp_liq_price(\n        self,\n        perp_market_index: int,\n    ) -&gt; Optional[int]:\n        position = await self.get_user_position(perp_market_index)\n        if position is None or position.base_asset_amount == 0:\n            return None\n\n        total_collateral = await self.get_total_collateral(MarginCategory.MAINTENANCE)\n        margin_req = await self.get_margin_requirement(MarginCategory.MAINTENANCE)\n        delta_liq = total_collateral - margin_req\n\n        perp_market = await self.get_perp_market(perp_market_index)\n        delta_per_baa = delta_liq / (position.base_asset_amount / AMM_RESERVE_PRECISION)\n\n        oracle_price = (\n            await self.get_perp_oracle_data(perp_market)\n        ).price / PRICE_PRECISION\n\n        liq_price = oracle_price - (delta_per_baa / QUOTE_PRECISION)\n        if liq_price &lt; 0:\n            return None\n\n        return liq_price\n\n    async def get_spot_liq_price(\n        self,\n        spot_market_index: int,\n    ) -&gt; Optional[int]:\n        position = await self.get_user_spot_position(spot_market_index)\n        if position is None:\n            return None\n\n        total_collateral = await self.get_total_collateral(MarginCategory.MAINTENANCE)\n        margin_req = await self.get_margin_requirement(\n            MarginCategory.MAINTENANCE, None, True, False\n        )\n        delta_liq = total_collateral - margin_req\n\n        spot_market = await self.get_spot_market(spot_market_index)\n        token_amount = get_token_amount(\n            position.scaled_balance, spot_market, position.balance_type\n        )\n        token_amount_qp = token_amount * QUOTE_PRECISION / (10**spot_market.decimals)\n        if abs(token_amount_qp) == 0:\n            return None\n\n        match str(position.balance_type):\n            case \"SpotBalanceType.Borrow()\":\n                liq_price_delta = (\n                    delta_liq\n                    * PRICE_PRECISION\n                    * SPOT_WEIGHT_PRECISION\n                    / token_amount_qp\n                    / spot_market.maintenance_liability_weight\n                )\n            case \"SpotBalanceType.Deposit()\":\n                liq_price_delta = (\n                    delta_liq\n                    * PRICE_PRECISION\n                    * SPOT_WEIGHT_PRECISION\n                    / token_amount_qp\n                    / spot_market.maintenance_asset_weight\n                    * -1\n                )\n            case _:\n                raise Exception(f\"Invalid balance type: {position.balance_type}\")\n\n        price = (await self.get_spot_oracle_data(spot_market)).price\n        liq_price = price + liq_price_delta\n        liq_price /= PRICE_PRECISION\n\n        if liq_price &lt; 0:\n            return None\n\n        return liq_price\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.authority","title":"<code>authority = authority</code>  <code>instance-attribute</code>","text":""},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.cache_is_set","title":"<code>cache_is_set = False</code>  <code>instance-attribute</code>","text":""},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.clearing_house","title":"<code>clearing_house = clearing_house</code>  <code>instance-attribute</code>","text":""},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.connection","title":"<code>connection = self.program.provider.connection</code>  <code>instance-attribute</code>","text":""},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.oracle_program","title":"<code>oracle_program = clearing_house</code>  <code>instance-attribute</code>","text":""},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.program","title":"<code>program = clearing_house.program</code>  <code>instance-attribute</code>","text":""},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.subaccount_id","title":"<code>subaccount_id = subaccount_id</code>  <code>instance-attribute</code>","text":""},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.use_cache","title":"<code>use_cache = use_cache</code>  <code>instance-attribute</code>","text":""},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.__init__","title":"<code>__init__(clearing_house, authority=None, subaccount_id=0, use_cache=False)</code>","text":"<p>Initialize the clearing house user object</p> <p>Parameters:</p> Name Type Description Default <code>clearing_house</code> <code>ClearingHouse</code> <p>required for program_id, idl, things (keypair doesnt matter)</p> required <code>authority</code> <code>Optional[PublicKey]</code> <p>authority to investigate if None will use clearing_house.authority</p> <code>None</code> <code>subaccount_id</code> <code>int</code> <p>subaccount of authority to investigate. Defaults to 0.</p> <code>0</code> <code>use_cache</code> <code>bool</code> <p>sdk uses a lot of rpc calls rn - use this flag and .set_cache() to cache accounts and reduce rpc calls. Defaults to False.</p> <code>False</code> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>def __init__(\n    self,\n    clearing_house: ClearingHouse,\n    authority: Optional[PublicKey] = None,\n    subaccount_id: int = 0,\n    use_cache: bool = False,\n):\n\"\"\"Initialize the clearing house user object\n\n    Args:\n        clearing_house (ClearingHouse): required for program_id, idl, things (keypair doesnt matter)\n        authority (Optional[PublicKey], optional): authority to investigate if None will use clearing_house.authority\n        subaccount_id (int, optional): subaccount of authority to investigate. Defaults to 0.\n        use_cache (bool, optional): sdk uses a lot of rpc calls rn - use this flag and .set_cache() to cache accounts and reduce rpc calls. Defaults to False.\n    \"\"\"\n    self.clearing_house = clearing_house\n    self.authority = authority\n    if self.authority is None:\n        self.authority = clearing_house.authority\n\n    self.program = clearing_house.program\n    self.oracle_program = clearing_house\n    self.connection = self.program.provider.connection\n    self.subaccount_id = subaccount_id\n    self.use_cache = use_cache\n    self.cache_is_set = False\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.can_be_liquidated","title":"<code>can_be_liquidated()</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def can_be_liquidated(self) -&gt; bool:\n    total_collateral = await self.get_total_collateral()\n\n    user = await self.get_user()\n    liquidation_buffer = None\n    if user.being_liquidated:\n        liquidation_buffer = (\n            await self.get_state()\n        ).liquidation_margin_buffer_ratio\n\n    maintenance_req = await self.get_margin_requirement(\n        MarginCategory.MAINTENANCE, liquidation_buffer\n    )\n\n    return total_collateral &lt; maintenance_req\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.get_free_collateral","title":"<code>get_free_collateral()</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def get_free_collateral(self):\n    total_collateral = await self.get_total_collateral()\n    init_margin_req = await self.get_margin_requirement(\n        MarginCategory.INITIAL,\n    )\n    free_collateral = total_collateral - init_margin_req\n    free_collateral = max(0, free_collateral)\n    return free_collateral\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.get_leverage","title":"<code>get_leverage(margin_category=None)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def get_leverage(\n    self, margin_category: Optional[MarginCategory] = None\n) -&gt; int:\n    total_liability = await self.get_margin_requirement(margin_category, None)\n    total_asset_value = await self.get_total_collateral(margin_category)\n\n    if total_asset_value == 0 or total_liability == 0:\n        return 0\n\n    leverage = total_liability * 10_000 / total_asset_value\n\n    return leverage\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.get_margin_requirement","title":"<code>get_margin_requirement(margin_category, liquidation_buffer=0, include_open_orders=True, include_spot=True)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def get_margin_requirement(\n    self,\n    margin_category: MarginCategory,\n    liquidation_buffer: Optional[int] = 0,\n    include_open_orders=True,\n    include_spot=True,\n) -&gt; int:\n    perp_liability = await self.get_total_perp_liability(\n        margin_category, liquidation_buffer, include_open_orders\n    )\n\n    result = perp_liability\n    if include_spot:\n        spot_liability = await self.get_spot_market_liability(\n            None, margin_category, liquidation_buffer, include_open_orders\n        )\n        result += spot_liability\n\n    return result\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.get_perp_liq_price","title":"<code>get_perp_liq_price(perp_market_index)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def get_perp_liq_price(\n    self,\n    perp_market_index: int,\n) -&gt; Optional[int]:\n    position = await self.get_user_position(perp_market_index)\n    if position is None or position.base_asset_amount == 0:\n        return None\n\n    total_collateral = await self.get_total_collateral(MarginCategory.MAINTENANCE)\n    margin_req = await self.get_margin_requirement(MarginCategory.MAINTENANCE)\n    delta_liq = total_collateral - margin_req\n\n    perp_market = await self.get_perp_market(perp_market_index)\n    delta_per_baa = delta_liq / (position.base_asset_amount / AMM_RESERVE_PRECISION)\n\n    oracle_price = (\n        await self.get_perp_oracle_data(perp_market)\n    ).price / PRICE_PRECISION\n\n    liq_price = oracle_price - (delta_per_baa / QUOTE_PRECISION)\n    if liq_price &lt; 0:\n        return None\n\n    return liq_price\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.get_perp_market","title":"<code>get_perp_market(i)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def get_perp_market(self, i):\n    if self.use_cache:\n        assert self.cache_is_set, \"must call clearing_house_user.set_cache() first\"\n        return self.CACHE[\"perp_markets\"][i]\n    else:\n        return await get_perp_market_account(self.program, i)\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.get_perp_oracle_data","title":"<code>get_perp_oracle_data(perp_market)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def get_perp_oracle_data(self, perp_market: PerpMarket):\n    if self.use_cache:\n        assert self.cache_is_set, \"must call clearing_house_user.set_cache() first\"\n        return self.CACHE[\"perp_market_oracles\"][perp_market.market_index]\n    else:\n        oracle_data = await get_oracle_data(self.connection, perp_market.amm.oracle,  perp_market.amm.oracle_source)\n        return oracle_data\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.get_spot_liq_price","title":"<code>get_spot_liq_price(spot_market_index)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def get_spot_liq_price(\n    self,\n    spot_market_index: int,\n) -&gt; Optional[int]:\n    position = await self.get_user_spot_position(spot_market_index)\n    if position is None:\n        return None\n\n    total_collateral = await self.get_total_collateral(MarginCategory.MAINTENANCE)\n    margin_req = await self.get_margin_requirement(\n        MarginCategory.MAINTENANCE, None, True, False\n    )\n    delta_liq = total_collateral - margin_req\n\n    spot_market = await self.get_spot_market(spot_market_index)\n    token_amount = get_token_amount(\n        position.scaled_balance, spot_market, position.balance_type\n    )\n    token_amount_qp = token_amount * QUOTE_PRECISION / (10**spot_market.decimals)\n    if abs(token_amount_qp) == 0:\n        return None\n\n    match str(position.balance_type):\n        case \"SpotBalanceType.Borrow()\":\n            liq_price_delta = (\n                delta_liq\n                * PRICE_PRECISION\n                * SPOT_WEIGHT_PRECISION\n                / token_amount_qp\n                / spot_market.maintenance_liability_weight\n            )\n        case \"SpotBalanceType.Deposit()\":\n            liq_price_delta = (\n                delta_liq\n                * PRICE_PRECISION\n                * SPOT_WEIGHT_PRECISION\n                / token_amount_qp\n                / spot_market.maintenance_asset_weight\n                * -1\n            )\n        case _:\n            raise Exception(f\"Invalid balance type: {position.balance_type}\")\n\n    price = (await self.get_spot_oracle_data(spot_market)).price\n    liq_price = price + liq_price_delta\n    liq_price /= PRICE_PRECISION\n\n    if liq_price &lt; 0:\n        return None\n\n    return liq_price\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.get_spot_market","title":"<code>get_spot_market(i)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def get_spot_market(self, i):\n    if self.use_cache:\n        assert self.cache_is_set, \"must call clearing_house_user.set_cache() first\"\n        return self.CACHE[\"spot_markets\"][i]\n    else:\n        return await get_spot_market_account(self.program, i)\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.get_spot_market_asset_value","title":"<code>get_spot_market_asset_value(margin_category=None, include_open_orders=True, market_index=None)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def get_spot_market_asset_value(\n    self,\n    margin_category: Optional[MarginCategory] = None,\n    include_open_orders=True,\n    market_index: Optional[int] = None,\n):\n    user = await self.get_user()\n    total_value = 0\n    for position in user.spot_positions:\n        if is_spot_position_available(position) or (\n            market_index is not None and position.market_index != market_index\n        ):\n            continue\n\n        spot_market = await self.get_spot_market(position.market_index)\n\n        if position.market_index == QUOTE_ASSET_BANK_INDEX:\n            spot_token_value = get_token_amount(\n                position.scaled_balance, spot_market, position.balance_type\n            )\n\n            match str(position.balance_type):\n                case \"SpotBalanceType.Deposit()\":\n                    spot_token_value *= 1\n                case \"SpotBalanceType.Borrow()\":\n                    spot_token_value *= -1\n                case _:\n                    raise Exception(\n                        f\"Invalid balance type: {position.balance_type}\"\n                    )\n\n            total_value += spot_token_value\n            continue\n\n        oracle_data = await self.get_spot_oracle_data(spot_market)\n\n        if not include_open_orders:\n            token_amount = get_token_amount(\n                    position.scaled_balance, spot_market, position.balance_type\n                )\n            spot_token_value = get_spot_asset_value(\n                    token_amount, oracle_data, spot_market, margin_category\n                )           \n            match str(position.balance_type):\n                case \"SpotBalanceType.Deposit()\":\n                    spot_token_value *= 1\n                case \"SpotBalanceType.Borrow()\":\n                    spot_token_value *= -1\n                case _:\n                    raise Exception(\n                        f\"Invalid balance type: {position.balance_type}\"\n                    )\n            total_value += spot_token_value\n            continue\n\n        (\n            worst_case_token_amount,\n            worst_case_quote_amount,\n        ) = get_worst_case_token_amounts(position, spot_market, oracle_data)\n\n        if worst_case_token_amount &gt; 0:\n            baa_value = get_spot_asset_value(\n                worst_case_token_amount, oracle_data, spot_market, margin_category\n            )\n            total_value += baa_value\n\n        if worst_case_quote_amount &gt; 0:\n            total_value += worst_case_quote_amount\n\n    return total_value\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.get_spot_market_liability","title":"<code>get_spot_market_liability(market_index=None, margin_category=None, liquidation_buffer=None, include_open_orders=None)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def get_spot_market_liability(\n    self,\n    market_index=None,\n    margin_category=None,\n    liquidation_buffer=None,\n    include_open_orders=None,\n):\n    user = await self.get_user()\n    total_liability = 0\n    for position in user.spot_positions:\n        if is_spot_position_available(position) or (\n            market_index is not None and position.market_index != market_index\n        ):\n            continue\n\n        spot_market = await self.get_spot_market(position.market_index)\n\n        if position.market_index == QUOTE_ASSET_BANK_INDEX:\n            if str(position.balance_type) == \"SpotBalanceType.Borrow()\":\n                token_amount = get_token_amount(\n                    position.scaled_balance, spot_market, position.balance_type\n                )\n                weight = SPOT_WEIGHT_PRECISION\n                if margin_category == MarginCategory.INITIAL:\n                    weight = max(weight, user.max_margin_ratio)\n\n                value = token_amount * weight / SPOT_WEIGHT_PRECISION\n                total_liability += value\n                continue\n            else:\n                continue\n\n        oracle_data = await self.get_spot_oracle_data(spot_market)\n        if not include_open_orders:\n            if str(position.balance_type) == \"SpotBalanceType.Borrow()\":\n                token_amount = get_token_amount(\n                    position.scaled_balance, spot_market, position.balance_type\n                )\n                liability_value = get_spot_liability_value(\n                    token_amount,\n                    oracle_data,\n                    spot_market,\n                    margin_category,\n                    liquidation_buffer,\n                    user.max_margin_ratio,\n                )\n                total_liability += liability_value\n                continue\n            else:\n                continue\n\n        (\n            worst_case_token_amount,\n            worst_case_quote_amount,\n        ) = get_worst_case_token_amounts(position, spot_market, oracle_data)\n\n        if worst_case_token_amount &lt; 0:\n            baa_value = get_spot_liability_value(\n                abs(worst_case_token_amount),\n                oracle_data,\n                spot_market,\n                margin_category,\n                liquidation_buffer,\n                user.max_margin_ratio,\n            )\n            total_liability += baa_value\n\n        if worst_case_quote_amount &lt; 0:\n            weight = SPOT_WEIGHT_PRECISION\n            if margin_category == MarginCategory.INITIAL:\n                weight = max(weight, user.max_margin_ratio)\n            weighted_value = (\n                abs(worst_case_quote_amount) * weight / SPOT_WEIGHT_PRECISION\n            )\n            total_liability += weighted_value\n\n    return total_liability\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.get_spot_oracle_data","title":"<code>get_spot_oracle_data(spot_market)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def get_spot_oracle_data(self, spot_market: SpotMarket):\n    if self.use_cache:\n        assert self.cache_is_set, \"must call clearing_house_user.set_cache() first\"\n        return self.CACHE[\"spot_market_oracles\"][spot_market.market_index]\n    else:\n        oracle_data = await get_oracle_data(self.connection, spot_market.oracle, spot_market.oracle_source)\n        return oracle_data\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.get_state","title":"<code>get_state()</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def get_state(self):\n    if self.use_cache:\n        assert self.cache_is_set, \"must call clearing_house_user.set_cache() first\"\n        return self.CACHE[\"state\"]\n    else:\n        return await get_state_account(self.program)\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.get_total_collateral","title":"<code>get_total_collateral(margin_category=None)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def get_total_collateral(\n    self, margin_category: Optional[MarginCategory] = None\n) -&gt; int:\n    spot_collateral = await self.get_spot_market_asset_value(\n        margin_category,\n        include_open_orders=True,\n    )\n    pnl = await self.get_unrealized_pnl(\n        True, with_weight_margin_category=margin_category\n    )\n    total_collateral = spot_collateral + pnl\n    return total_collateral\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.get_total_perp_liability","title":"<code>get_total_perp_liability(margin_category=None, liquidation_buffer=0, include_open_orders=False)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def get_total_perp_liability(\n    self,\n    margin_category: Optional[MarginCategory] = None,\n    liquidation_buffer: Optional[int] = 0,\n    include_open_orders: bool = False,\n):\n    user = await self.get_user()\n\n    unrealized_pnl = 0\n    for position in user.perp_positions:\n        market = await self.get_perp_market(position.market_index)\n\n        if position.lp_shares &gt; 0:\n            pass\n\n        price = (await self.get_perp_oracle_data(market)).price\n        base_asset_amount = (\n            calculate_worst_case_base_asset_amount(position)\n            if include_open_orders\n            else position.base_asset_amount\n        )\n        base_value = (\n            abs(base_asset_amount)\n            * price\n            / (AMM_TO_QUOTE_PRECISION_RATIO * PRICE_PRECISION)\n        )\n\n        if margin_category is not None:\n            margin_ratio = calculate_market_margin_ratio(\n                market, abs(base_asset_amount), margin_category\n            )\n\n            if margin_category == MarginCategory.INITIAL:\n                margin_ratio = max(margin_ratio, user.max_margin_ratio)\n\n            if liquidation_buffer is not None:\n                margin_ratio += liquidation_buffer\n\n            base_value = base_value * margin_ratio / MARGIN_PRECISION\n\n        unrealized_pnl += base_value\n    return unrealized_pnl\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.get_unrealized_pnl","title":"<code>get_unrealized_pnl(with_funding=False, market_index=None, with_weight_margin_category=None)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def get_unrealized_pnl(\n    self,\n    with_funding: bool = False,\n    market_index: int = None,\n    with_weight_margin_category: Optional[MarginCategory] = None,\n):\n    user = await self.get_user()\n    quote_spot_market = await self.get_spot_market(QUOTE_ASSET_BANK_INDEX)\n\n    unrealized_pnl = 0\n    position: PerpPosition\n    for position in user.perp_positions:\n        if market_index is not None and position.market_index != market_index:\n            continue\n\n        market = await self.get_perp_market(position.market_index)\n\n        oracle_data = await self.get_perp_oracle_data(market)\n        position_unrealized_pnl = calculate_position_pnl_with_oracle(\n            market, position, oracle_data, with_funding\n        )\n\n        if with_weight_margin_category is not None:\n            if position_unrealized_pnl &gt; 0:\n                unrealized_asset_weight = calculate_unrealized_asset_weight(\n                    market,\n                    quote_spot_market,\n                    position_unrealized_pnl,\n                    with_weight_margin_category,\n                    oracle_data,\n                )\n                position_unrealized_pnl = (\n                    position_unrealized_pnl\n                    * unrealized_asset_weight\n                    / SPOT_WEIGHT_PRECISION\n                )\n\n        unrealized_pnl += position_unrealized_pnl\n\n    return unrealized_pnl\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.get_user","title":"<code>get_user()</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def get_user(self):\n    if self.use_cache:\n        assert self.cache_is_set, \"must call clearing_house_user.set_cache() first\"\n        return self.CACHE[\"user\"]\n    else:\n        return await get_user_account(\n            self.program, self.authority, self.subaccount_id\n        )\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.get_user_position","title":"<code>get_user_position(market_index)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def get_user_position(\n    self,\n    market_index: int,\n) -&gt; Optional[PerpPosition]:\n    user = await self.get_user()\n\n    found = False\n    for position in user.perp_positions:\n        if position.market_index == market_index and not is_available(position):\n            found = True\n            break\n\n    if not found:\n        return None\n\n    return position\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.get_user_spot_position","title":"<code>get_user_spot_position(market_index)</code>  <code>async</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def get_user_spot_position(\n    self,\n    market_index: int,\n) -&gt; Optional[SpotPosition]:\n    user = await self.get_user()\n\n    found = False\n    for position in user.spot_positions:\n        if (\n            position.market_index == market_index\n            and not is_spot_position_available(position)\n        ):\n            found = True\n            break\n\n    if not found:\n        return None\n\n    return position\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.set_cache","title":"<code>set_cache(CACHE=None)</code>  <code>async</code>","text":"<p>sets the cache of the accounts to use to inspect</p> <p>Parameters:</p> Name Type Description Default <code>CACHE</code> <code>dict</code> <p>other existing cache object - if None will pull \u0192resh accounts from RPC. Defaults to None.</p> <code>None</code> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def set_cache(self, CACHE=None):\n\"\"\"sets the cache of the accounts to use to inspect\n\n    Args:\n        CACHE (dict, optional): other existing cache object - if None will pull \u0192resh accounts from RPC. Defaults to None.\n    \"\"\"\n    self.cache_is_set = True\n\n    if CACHE is not None:\n        self.CACHE = CACHE\n        return\n\n    self.CACHE = {}\n    state = await get_state_account(self.program)\n    self.CACHE[\"state\"] = state\n\n    spot_markets = []\n    spot_market_oracle_data = []\n    for i in range(state.number_of_spot_markets):\n        spot_market = await get_spot_market_account(self.program, i)\n        spot_markets.append(spot_market)\n\n        if i == 0:\n            spot_market_oracle_data.append(\n                OracleData(PRICE_PRECISION, 0, 1, 1, 0, True)\n            )\n        else:\n            oracle_data = await get_oracle_data(self.connection, spot_market.oracle,  spot_market.oracle_source)\n            spot_market_oracle_data.append(oracle_data)\n\n    self.CACHE[\"spot_markets\"] = spot_markets\n    self.CACHE[\"spot_market_oracles\"] = spot_market_oracle_data\n\n    perp_markets = []\n    perp_market_oracle_data = []\n    for i in range(state.number_of_markets):\n        perp_market = await get_perp_market_account(self.program, i)\n        perp_markets.append(perp_market)\n\n        oracle_data = await get_oracle_data(self.connection, perp_market.amm.oracle, perp_market.amm.oracle_source)\n        perp_market_oracle_data.append(oracle_data)\n\n    self.CACHE[\"perp_markets\"] = perp_markets\n    self.CACHE[\"perp_market_oracles\"] = perp_market_oracle_data\n\n    user = await get_user_account(self.program, self.authority, self.subaccount_id)\n    self.CACHE[\"user\"] = user\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.ClearingHouseUser.set_cache_last","title":"<code>set_cache_last(CACHE=None)</code>  <code>async</code>","text":"<p>sets the cache of the accounts to use to inspect</p> <p>Parameters:</p> Name Type Description Default <code>CACHE</code> <code>dict</code> <p>other existing cache object - if None will pull \u0192resh accounts from RPC. Defaults to None.</p> <code>None</code> Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>async def set_cache_last(self, CACHE=None):\n\"\"\"sets the cache of the accounts to use to inspect\n\n    Args:\n        CACHE (dict, optional): other existing cache object - if None will pull \u0192resh accounts from RPC. Defaults to None.\n    \"\"\"\n    self.cache_is_set = True\n\n    if CACHE is not None:\n        self.CACHE = CACHE\n        return\n\n    self.CACHE = {}\n    state = await get_state_account(self.program)\n    self.CACHE[\"state\"] = state\n\n    spot_markets = []\n    spot_market_oracle_data = []\n    for i in range(state.number_of_spot_markets):\n        spot_market = await get_spot_market_account(self.program, i)\n        spot_markets.append(spot_market)\n\n        if i == 0:\n            spot_market_oracle_data.append(\n                OracleData(PRICE_PRECISION, 0, 1, 1, 0, True)\n            )\n        else:\n            oracle_data = OracleData(\n                spot_market.historical_oracle_data.last_oracle_price,\n                0,\n                1,\n                1,\n                0,\n                True,\n            )\n            spot_market_oracle_data.append(oracle_data)\n\n    self.CACHE[\"spot_markets\"] = spot_markets\n    self.CACHE[\"spot_market_oracles\"] = spot_market_oracle_data\n\n    perp_markets = []\n    perp_market_oracle_data = []\n    for i in range(state.number_of_markets):\n        perp_market = await get_perp_market_account(self.program, i)\n        perp_markets.append(perp_market)\n\n        oracle_data = OracleData(\n            perp_market.amm.historical_oracle_data.last_oracle_price,\n            0,\n            1,\n            1,\n            0,\n            True,\n        )\n        perp_market_oracle_data.append(oracle_data)\n\n    self.CACHE[\"perp_markets\"] = perp_markets\n    self.CACHE[\"perp_market_oracles\"] = perp_market_oracle_data\n\n    user = await get_user_account(self.program, self.authority, self.subaccount_id)\n    self.CACHE[\"user\"] = user\n</code></pre>"},{"location":"clearing_house_user/#driftpy.clearing_house_user.find","title":"<code>find(l, f)</code>","text":"Source code in <code>/opt/hostedtoolcache/Python/3.10.12/x64/lib/python3.10/site-packages/driftpy/clearing_house_user.py</code> <pre><code>def find(l: list, f):\n    valid_values = [v for v in l if f(v)]\n    if len(valid_values) == 0:\n        return None\n    else:\n        return valid_values[0]\n</code></pre>"}]}